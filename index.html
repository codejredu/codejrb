<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>בלוקלי: פריסה בסגנון סקראץ'</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/blockly@9.0.0/blockly.min.js"></script>
    <link rel="stylesheet" href="index.css">
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-gray-100 text-gray-800">
    <div id="project-controls" class="w-full shadow-md p-2 flex justify-between items-center fixed top-0 left-0 z-50" style="background-color: #855CD6;" dir="rtl">
        <div class="flex items-center gap-4">
            <button id="save-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M7.707 10.293a1 1 0 10-1.414 1.414l3 3a1 1 0 001.414 0l3-3a1 1 0 00-1.414-1.414L11 11.586V6a1 1 0 10-2 0v5.586L7.707 10.293zM5 4a1 1 0 011-1h8a1 1 0 011 1v1h-2V5H7v1H5V4z"/>
                    <path fill-rule="evenodd" d="M3 13a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm1-3a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1z" clip-rule="evenodd" />
                </svg>
                <span>שמור פרויקט</span>
            </button>
            <button id="load-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2 transition-colors">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                  <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                </svg>
                <span>טען פרויקט</span>
            </button>
            <input type="file" id="load-input" class="hidden" accept=".kidi, .json">
        </div>
        <h1 class="text-2xl font-bold text-white px-4">קודקידי</h1>
    </div>


    <div id="container-wrapper" class="container-wrapper">
        <div class="left-panel">
            <div id="stage-header">
                <h2 class="panel-title text-xl font-bold">במה</h2>
                <div id="stage-controls">
                    <button id="run-button" class="w-10 h-10 bg-green-500 text-white font-bold rounded-full flex justify-center items-center shadow-md hover:bg-green-600 transition-colors" title="הפעל">
                        <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M6 3v18h2v-8h10l-4-5 4-5H8V3H6z"/></svg>
                    </button>
                    <button id="reset-button" class="w-10 h-10 bg-red-500 text-white font-bold rounded-full flex justify-center items-center shadow-md hover:bg-red-600 transition-colors" title="עצור">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                          <path d="M4 3a1 1 0 00-1 1v12a1 1 0 001 1h12a1 1 0 001-1V4a1 1 0 00-1-1H4z" />
                        </svg>
                    </button>
                    <button id="fullscreen-button" class="w-10 h-10 bg-blue-500 text-white font-bold rounded-full flex justify-center items-center shadow-md hover:bg-blue-600 transition-colors" title="מסך מלא">
                         <img id="enter-fullscreen-icon" src="https://codejredu.github.io/test/assets/blocklyicon/fullscreen.svg" class="h-7 w-7">
                         <svg id="exit-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" class="h-7 w-7 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                            <path stroke-linecap="round" stroke-linejoin="round" d="M8 4H4m0 0v4m0-4l5 5m1-5h4m0 0v4m0-4l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5v-4m0 0h-4m4 0l-5-5" />
                        </svg>
                    </button>
                </div>
            </div>
            <div id="stage-aspect-ratio-wrapper" class="w-full relative">
                <div id="stage-area"></div>
            </div>
            
            <div id="sprite-properties-panel" class="section hidden">
                <div class="flex flex-wrap items-center gap-x-6 gap-y-3 text-sm">
                    <div class="flex items-center gap-2">
                        <label for="prop-name" class="font-medium">דמות:</label>
                        <input type="text" id="prop-name" class="p-1 border rounded-lg w-24">
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="prop-x" class="font-medium">X:</label>
                        <input type="number" id="prop-x" class="p-1 border rounded-lg w-16 text-center">
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="prop-y" class="font-medium">Y:</label>
                        <input type="number" id="prop-y" class="p-1 border rounded-lg w-16 text-center">
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="prop-size" class="font-medium">גודל:</label>
                        <input type="number" id="prop-size" min="0" class="p-1 border rounded-lg w-16 text-center">
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="prop-direction" class="font-medium">כיוון:</label>
                        <input type="number" id="prop-direction" class="p-1 border rounded-lg w-16 text-center">
                    </div>
                    <div class="flex items-center gap-2">
                        <label class="font-medium">הצגה:</label>
                        <div class="flex bg-gray-200 rounded-lg p-0.5">
                            <button id="prop-show" class="p-1.5 rounded-md flex justify-center items-center focus:outline-none" title="הצג">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 pointer-events-none" viewBox="0 0 20 20" fill="currentColor"><path d="M10 12a2 2 0 100-4 2 2 0 000 4z" /><path fill-rule="evenodd" d="M.458 10C3.732 4.943 7.523 3 10 3s6.268 1.943 9.542 7c-3.274 5.057-7.27 7-9.542 7S3.732 15.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd" /></svg>
                            </button>
                            <button id="prop-hide" class="p-1.5 rounded-md flex justify-center items-center focus:outline-none" title="הסתר">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 pointer-events-none" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.27 8.138 16.545 7 14.66 6.36l-1.07-1.071A9.95 9.95 0 0010 3C4.943 3 1.943 7.732 1.458 9.227l-1.473-1.473a1 1 0 00-1.414 0zM10 12a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" /><path d="M10 15a5 5 0 004.95-4.286l-1.543-1.543A3.001 3.001 0 0110 13a3 3 0 01-2.43-1.088l-1.528-1.528A4.982 4.982 0 005.05 10.714 5 5 0 0010 15z" /></svg>
                            </button>
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                        <label class="font-medium">סיבוב:</label>
                        <div id="prop-rotation-style" class="flex bg-gray-200 rounded-lg p-0.5">
                            <button id="rotation-all-around" class="p-1.5 rounded-md flex justify-center items-center focus:outline-none" title="לכל הכיוונים">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10" />
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M23 4v6h-6" />
                                </svg>
                            </button>
                            <button id="rotation-left-right" class="p-1.5 rounded-md flex justify-center items-center focus:outline-none" title="שמאל-ימין">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M7 16l-4-4m0 0l4-4m-4 4h18m-7 4l4-4m0 0l-4-4m4 4H3" />
                                </svg>
                            </button>
                            <button id="rotation-dont-rotate" class="p-1.5 rounded-md flex justify-center items-center focus:outline-none" title="ללא סיבוב">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 pointer-events-none" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v3m0 3h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                 <div id="gif-animation-panel" class="hidden mt-4 pt-4 border-t border-gray-200">
                    <h3 class="font-medium text-base mb-2">בקרת אנימציה</h3>
                    <div class="flex items-center gap-4 text-sm">
                        <button id="gif-play-pause-btn" class="w-8 h-8 bg-blue-500 text-white rounded-full flex justify-center items-center shadow-md hover:bg-blue-600 transition-colors flex-shrink-0" title="נגן/השהה">
                            <svg id="gif-play-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                            </svg>
                            <svg id="gif-pause-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 hidden" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1zm4 0a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                        </button>
                        <div class="flex-grow flex items-center gap-2">
                            <label for="gif-speed-slider" class="font-medium">מהירות:</label>
                            <input type="range" id="gif-speed-slider" min="0.1" max="3" step="0.1" value="1" class="w-full">
                            <span id="gif-speed-value" class="font-mono w-12 text-center bg-gray-100 rounded p-1">1.0x</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-header">
                    <h2>דמויות</h2>
                    <div class="header-actions">
                         <div id="create-sprite-header-button" class="header-button" title="צור דמות">
                             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />
                             </svg>
                         </div>
                         <div id="upload-sprite-header-button" class="header-button" title="העלה דמות">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
                            </svg>
                         </div>
                         <div id="add-sprite-button" class="header-button" title="בחר דמות">
                            <span class="text-xl font-bold">+</span>
                         </div>
                    </div>
                </div>
                <div id="sprites-carousel-wrapper" class="relative mt-4">
                     <div id="sprites-list" class="flex items-center gap-4">
                        <!-- Sprites will be dynamically added here -->
                    </div>
                </div>
                <div id="sprite-gallery" class="gallery-container">
                    <button class="close-gallery-button" id="close-sprite-gallery-button">X</button>
                    <h2 class="text-xl font-bold text-center mb-4">גלריית דמויות</h2>
                    <div id="sprite-thumbnails-grid" class="thumbnail-grid">
                        <!-- The create/upload buttons are removed from here -->
                        <img src="https://codejredu.github.io/claudejr/Chick.svg" alt="Chick" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Rabbit.svg" alt="Rabbit" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Beetle.svg" alt="Beetle" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/GingerCat.svg" alt="GingerCat" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/AmericanFootball.svg" alt="AmericanFootball" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Basketball.svg" alt="Basketball" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Football.svg" alt="Football" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Dog.svg" alt="Dog" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/PistonPlane.svg" alt="PistonPlane" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/ColorfulPlane.svg" alt="ColorfulPlane" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/YellowCar.svg" alt="YellowCar" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Helicopter.svg" alt="Helicopter" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/SpaceShuttle.svg" alt="SpaceShuttle" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Truck.svg" alt="Truck" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Tiger.svg" alt="Tiger" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Rhino.svg" alt="Rhino" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Spindle.svg" alt="Spindle" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Crab.svg" alt="Crab" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/GreenSpottedTree.svg" alt="GreenSpottedTree" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Flamingo.svg" alt="Flamingo" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Flower.svg" alt="Flower" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Monkey.svg" alt="Monkey" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/Crocodile.svg" alt="Crocodile" class="thumbnail">
                        <img src="https://codejredu.github.io/claudejr/falcon.svg" alt="Falcon" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/waman%20dance.gif" alt="Waman Dance" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/CAR.gif" alt="Car" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/Hedgehog.gif" alt="Hedgehog" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/KIDWALK.gif" alt="Kid Walk" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/bee.gif" alt="Bee" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/bird2.gif" alt="Bird 2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/birdred.gif" alt="Red Bird" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/bycycle.gif" alt="Bicycle" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/car1.gif" alt="Car 1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/dance.gif" alt="Dance" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/dog.gif" alt="Dog" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/fox.gif" alt="Fox" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/gitarwaman.gif" alt="Guitar Woman" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/horse.gif" alt="Horse" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/kidwalk1.gif" alt="Kid Walk 1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/mouse.gif" alt="Mouse" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/ani/ostrich.gif" alt="Ostrich" class="thumbnail">
                    </div>
                    <input type="file" id="sprite-upload-input" class="hidden" accept="image/png, image/jpeg, image/gif, image/svg+xml">
                </div>
            </div>

            <div class="section" id="backdrops-section">
                <div class="section-header">
                    <h2>רקעים</h2>
                     <div class="header-actions">
                         <div id="upload-backdrop-header-button" class="header-button" title="העלה רקע">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
                            </svg>
                         </div>
                         <div id="add-backdrop-button" class="header-button" title="בחר רקע">
                           <span class="text-xl font-bold">+</span>
                         </div>
                    </div>
                </div>
                <div id="backdrops-carousel-wrapper" class="relative mt-4">
                    <div id="backdrops-list" class="flex items-center gap-4">
                        <!-- Backdrops will be dynamically added here -->
                    </div>
                </div>
                <div id="background-gallery" class="gallery-container">
                    <button class="close-gallery-button" id="close-gallery-button">X</button>
                    <h2 class="text-xl font-bold text-center mb-4">גלריית רקעים</h2>
                    <div id="thumbnails-grid" class="thumbnail-grid">
                        <!-- The upload button is removed from here -->
                        <img src="https://codejredu.github.io/test/assets/bg/Amphitheater.svg" alt="Amphitheater" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/canyon.svg" alt="canyon" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/canyon1.svg" alt="canyon1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/castel.svg" alt="castel" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/castel1.svg" alt="castel1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/citynight.svg" alt="citynight" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/citynight2.svg" alt="citynight2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/colorfulcity.svg" alt="colorfulcity" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/colorfulcity1.svg" alt="colorfulcity1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/desert.svg" alt="desert" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/desert1.svg" alt="desert1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/farm.svg" alt="farm" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/kidbadroom.svg" alt="kidbadroom" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/kidbadroom1.svg" alt="kidbadroom1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/moon.svg" alt="moon" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/road1.svg" alt="road1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/road2.svg" alt="road2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/room1.svg" alt="room1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/room2.svg" alt="room2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/savanna1.svg" alt="savanna1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/savanna2.svg" alt="savanna2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/school1.svg" alt="school1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/slopes1.svg" alt="slopes1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/slopes2.svg" alt="slopes2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/soccer1.svg" alt="soccer1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/soccer2.svg" alt="soccer2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/winter1.svg" alt="winter1" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/winter2.svg" alt="winter2" class="thumbnail">
                        <img src="https://codejredu.github.io/test/assets/bg/under.svg" alt="under" class="thumbnail">
                    </div>
                    <input type="file" id="backdrop-upload-input" class="hidden" accept="image/png, image/jpeg, image/gif, image/svg+xml">
                </div>
            </div>
        </div>

        <div class="right-panel">
            <div id="blockly-area" class="h-[80vh] min-h-[500px] w-full rounded-2xl"></div>
        </div>
    </div>
    
    <div id="number-pad-container" class="number-pad-container">
        <div id="number-pad-display" class="number-pad-display"></div>
        <div class="number-pad-grid">
            <button data-value="7">7</button>
            <button data-value="8">8</button>
            <button data-value="9">9</button>
            <button data-value="4">4</button>
            <button data-value="5">5</button>
            <button data-value="6">6</button>
            <button data-value="1">1</button>
            <button data-value="2">2</button>
            <button data-value="3">3</button>
            <button data-value="0">0</button>
            <button data-value=".">.</button>
            <button data-value="backspace">⌫</button>
        </div>
        <button id="number-pad-done" class="number-pad-done">אישור</button>
    </div>

    <div id="angle-picker-widget">
        <div id="angle-picker-dial">
            <div id="angle-picker-handle"></div>
        </div>
    </div>
    
    <!-- Character Creator Modal -->
    <div id="character-creator-modal">
        <div class="creator-content">
            <div class="creator-header">
                <h2>מחולל הדמויות</h2>
                <div class="flex gap-4">
                    <button id="creator-save-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-6 rounded-lg transition-colors">שמור</button>
                    <button id="creator-close-button" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg transition-colors">סגור</button>
                </div>
            </div>
            <div class="creator-main">
                <div class="creator-controls">
                    <div id="creator-categories" class="creator-categories">
                        <!-- Categories will be populated by JS -->
                    </div>
                    <div id="creator-parts-grid" class="creator-parts-grid">
                        <!-- Part thumbnails will be populated by JS -->
                    </div>
                </div>
                <div class="creator-preview">
                    <canvas id="character-canvas" width="400" height="400"></canvas>
                    <div id="creator-controls-panel" class="hidden">
                         <div class="text-center font-bold text-lg mb-2">
                           עריכת <span id="selected-part-label"></span>
                        </div>
                        <div id="creator-color-group" class="control-group">
                            <label>צבע:</label>
                            <div id="creator-color-palette">
                                <!-- Color swatches go here -->
                            </div>
                        </div>
                        <div id="creator-actions-group" class="control-group hidden">
                            <label>פעולות:</label>
                            <div class="flex gap-2">
                                <button id="creator-flip-h-button" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2 transition-colors hidden">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M7 16H3m4 0l-4-4m4 4l-4 4m18-4h-4m4 0l-4-4m4 4l-4 4M12 3v18" />
                                    </svg>
                                    <span>היפוך אופקי</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>


    <xml id="toolbox" style="display: none">
        <category 
            name="להפעיל" 
            colour="#FFE75A" 
            icon-uri="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23FFC107'><path d='M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z'/></svg>">
            <block type="event_when_flag_clicked"></block>
            <block type="event_when_sprite_clicked"></block>
            <block type="event_when_key_pressed"></block>
            <block type="event_when_bump"></block>
            <block type="event_broadcast"></block>
            <block type="event_when_broadcast_received"></block>
        </category>
        <category 
            name="בקרה" 
            colour="#FF6B1A"
            icon-uri="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23c45a11'><path d='M12 4c-4.418 0-8 3.582-8 8s3.582 8 8 8 8-3.582 8-8-3.582-8-8-8zm0 14c-3.309 0-6-2.691-6-6s2.691-6 6-6 6 2.691 6 6-2.691 6-6 6zm1-7.586V8h-2v4.414l3.293 3.293 1.414-1.414L13 10.414z' /></svg>">
            <block type="control_wait_secs">
                <value name="SECS">
                    <shadow type="math_number">
                        <field name="NUM">1</field>
                    </shadow>
                </value>
            </block>
            <block type="control_repeat_times">
                <value name="TIMES">
                    <shadow type="math_number">
                        <field name="NUM">10</field>
                    </shadow>
                </value>
            </block>
            <block type="control_forever"></block>
        </category>
        <category 
            name="תנועה" 
            colour="#4C97FF"
            icon-uri="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%233e83f7'><path d='M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z'/></svg>">
            <block type="motion_move_steps">
                <value name="STEPS">
                    <shadow type="math_number">
                        <field name="NUM">10</field>
                    </shadow>
                </value>
            </block>
            <block type="motion_turn_right_degrees">
                <value name="DEGREES">
                    <shadow type="math_number">
                        <field name="NUM">15</field>
                    </shadow>
                </value>
            </block>
            <block type="motion_turn_left_degrees">
                <value name="DEGREES">
                    <shadow type="math_number">
                        <field name="NUM">15</field>
                    </shadow>
                </value>
            </block>
            <block type="motion_set_direction">
                <field name="DEGREES">90</field>
            </block>
            <block type="motion_go_to_xy">
                <value name="X">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
                <value name="Y">
                    <shadow type="math_number">
                        <field name="NUM">0</field>
                    </shadow>
                </value>
            </block>
            <block type="motion_jump">
                <value name="HEIGHT">
                    <shadow type="math_number">
                        <field name="NUM">100</field>
                    </shadow>
                </value>
            </block>
        </category>
        <category 
            name="מראה" 
            colour="#9966FF"
            icon-uri="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%238a4cff'><path d='M12 2C6.486 2 2 6.486 2 12c0 3.553 1.846 6.63 4.566 8.332.148.066.33.024.437-.113.107-.137.07-.34-.063-.448C4.24 18.01 3 15.22 3 12c0-4.962 4.038-9 9-9s9 4.038 9 9-4.038 9-9 9c-.551 0-1-.449-1-1s.449-1 1-1c3.86 0 7-3.14 7-7s-3.14-7-7-7-7 3.14-7 7c0 1.294.358 2.502.984 3.558.125.208.04.473-.145.613-.185.14-.45.064-.59-.12C4.6 14.93 4 13.51 4 12c0-4.411 3.589-8 8-8s8 3.589 8-8 8z' /><path d='M11 7h2v6h-2zm0 8h2v2h-2z' /></svg>">
            <block type="looks_say_for_secs">
                <value name="MESSAGE">
                    <shadow type="text">
                        <field name="TEXT">שלום!</field>
                    </shadow>
                </value>
                <value name="SECS">
                    <shadow type="math_number">
                        <field name="NUM">2</field>
                    </shadow>
                </value>
            </block>
            <block type="looks_say">
                <value name="MESSAGE">
                    <shadow type="text">
                        <field name="TEXT">שלום!</field>
                    </shadow>
                </value>
            </block>
            <block type="looks_show"></block>
            <block type="looks_hide"></block>
            <block type="looks_grow">
                <value name="SIZE">
                    <shadow type="math_number">
                        <field name="NUM">10</field>
                    </shadow>
                </value>
            </block>
            <block type="looks_shrink">
                <value name="SIZE">
                    <shadow type="math_number">
                        <field name="NUM">10</field>
                    </shadow>
                </value>
            </block>
            <block type="looks_set_size">
                <value name="SIZE">
                    <shadow type="math_number">
                        <field name="NUM">100</field>
                    </shadow>
                </value>
            </block>
            <block type="looks_switch_backdrop"></block>
        </category>
        <category 
            name="צליל" 
            colour="#CF63CF"
            icon-uri="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23b858b8'><path d='M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z'></path></svg>">
             <block type="sound_play_until_done"></block>
        </category>
        <category 
            name="אופרטורים" 
            colour="#40BF4A"
            icon-uri="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23389a40'><path d='M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm4 11h-3v3h-2v-3H8v-2h3V8h2v3h3v2z' /></svg>">
            <block type="operator_add"></block>
            <block type="operator_subtract"></block>
            <block type="operator_multiply"></block>
            <block type="operator_divide"></block>
            <block type="operator_random_number">
                <field name="FROM">1</field>
                <field name="TO">10</field>
            </block>
            <block type="math_number"></block>
        </category>
    </xml>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // START OF CUSTOM TOOLBOX RENDERER
            
            /**
             * Safely encode a string to Base64, handling Unicode characters.
             * @param {string} str The string to encode.
             * @returns {string} The Base64 encoded string.
             */
            function safeBtoa(str) {
                // First, URI-encode the string, then convert to a format btoa can handle.
                return btoa(unescape(encodeURIComponent(str)));
            }
            
            /**
             * Safely decode a Base64 string, handling Unicode characters.
             * @param {string} base64 The Base64 string to decode.
             * @returns {string} The decoded string.
             */
            function safeAtob(base64) {
                 // First, atob the string, then decode the URI-encoded characters.
                return decodeURIComponent(escape(atob(base64)));
            }

            /**
             * Helper function to convert a hex color to an rgba string.
             * @param {string} hex The hex color string (e.g., "#FF6B1A").
             * @param {number} alpha The alpha transparency (0.0 to 1.0).
             * @returns {string} The rgba color string.
             */
            function hexToRgba(hex, alpha) {
                let r = 0, g = 0, b = 0;
                if (hex.length == 4) { // 3-digit hex
                    r = parseInt(hex[1] + hex[1], 16);
                    g = parseInt(hex[2] + hex[2], 16);
                    b = parseInt(hex[3] + hex[3], 16);
                } else if (hex.length == 7) { // 6-digit hex
                    r = parseInt(hex.substring(1, 3), 16);
                    g = parseInt(hex.substring(3, 5), 16);
                    b = parseInt(hex.substring(5, 7), 16);
                }
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }

            class KidiToolboxCategory extends Blockly.ToolboxCategory {
                createDom_() {
                    super.createDom_(); // Let the parent class create the basic structure

                    const iconUri = this.toolboxItemDef_['icon-uri'];
                    if (iconUri) {
                        const label = this.rowDiv_.querySelector('.blocklyTreeLabel');
                        if (label) {
                            const icon = document.createElement('img');
                            icon.src = iconUri;
                            icon.className = 'kidi-category-icon';
                            label.insertBefore(icon, label.firstChild);
                        }
                    }
                    
                    // Store colors in CSS variables on the element itself for the new CSS rule to use
                    this.rowDiv_.style.setProperty('--category-color', this.colour_);
                    this.rowDiv_.style.setProperty('--category-bg-color', hexToRgba(this.colour_, 0.08));
                    
                    return this.rowDiv_;
                }
                
                setSelected(isSelected) {
                    super.setSelected(isSelected);
                    // Just toggle a class. The CSS will handle the styling.
                    this.rowDiv_.classList.toggle('kidi-category-selected', isSelected);
                }
            }

            Blockly.registry.register(
                Blockly.registry.Type.TOOLBOX_ITEM,
                Blockly.ToolboxCategory.registrationName,
                KidiToolboxCategory, 
                true // Allow override
            );
            // END OF CUSTOM TOOLBOX RENDERER

            // START OF INLINED GIF PARSER
            // A simplified GIF parser based on jsgif.
            const parseGIF = (arrayBuffer) => {
                const data = new Uint8Array(arrayBuffer);
                let pos = 0;
                const frames = [];
                let gct = null;
                let loopCount = 0;

                const readString = (length) => {
                    let str = '';
                    for (let i = 0; i < length; i++) {
                        str += String.fromCharCode(data[pos++]);
                    }
                    return str;
                };

                const readByte = () => data[pos++];
                const readUInt16 = () => (readByte() | (readByte() << 8));
                
                const readColorTable = (size) => {
                    const table = [];
                    for (let i = 0; i < size; i++) {
                        table.push([readByte(), readByte(), readByte()]);
                    }
                    return table;
                };

                const readLZW = (minCodeSize, data, pixels) => {
                    let pos = 0; 
                    const readCode = (size) => {
                        let code = 0;
                        for (let i = 0; i < size; i++) {
                            if (data[pos >> 3] & (1 << (pos & 7))) {
                                code |= 1 << i;
                            }
                            pos++;
                        }
                        return code;
                    };
                    
                    const output = (index) => {
                        pixels.push(index);
                    };

                    const clearCode = 1 << minCodeSize;
                    const eoiCode = clearCode + 1;
                    let codeSize = minCodeSize + 1;
                    let dict = [];

                    const clear = () => {
                        dict = [];
                        codeSize = minCodeSize + 1;
                        for (let i = 0; i < clearCode; i++) {
                            dict[i] = [i];
                        }
                        dict[clearCode] = [];
                        dict[eoiCode] = null;
                    };

                    let code, last;
                    while (true) {
                        last = code;
                        code = readCode(codeSize);
                        if (code === clearCode) {
                            clear();
                            continue;
                        }
                        if (code === eoiCode) break;
                        if (code < dict.length) {
                            if (last !== clearCode) {
                                dict.push(dict[last].concat(dict[code][0]));
                            }
                        } else {
                            if (code !== dict.length) throw new Error('Invalid LZW code.');
                            dict.push(dict[last].concat(dict[last][0]));
                        }
                        dict[code].forEach(output);
                        if (dict.length === (1 << codeSize) && codeSize < 12) {
                            codeSize++;
                        }
                    }
                };

                // Header
                if (readString(6) !== 'GIF89a') throw new Error('Not a GIF file.');

                // Logical Screen Descriptor
                const width = readUInt16();
                const height = readUInt16();
                const packed = readByte();
                const gctFlag = (packed & 0x80) !== 0;
                const gctSize = 2 << (packed & 0x07);
                pos++; // Skip background color index
                pos++; // Skip pixel aspect ratio

                if (gctFlag) {
                    gct = readColorTable(gctSize);
                }

                let gce = null;
                while(pos < data.length) {
                    const blockType = readByte();
                    if (blockType === 0x2C) { // Image Descriptor
                        const left = readUInt16();
                        const top = readUInt16();
                        const w = readUInt16();
                        const h = readUInt16();
                        const packed = readByte();
                        const lctFlag = (packed & 0x80) !== 0;
                        const interlace = (packed & 0x40) !== 0;
                        const lctSize = 2 << (packed & 0x07);
                        const ct = lctFlag ? readColorTable(lctSize) : gct;

                        const minCodeSize = readByte();
                        const lzwData = [];
                        while (true) {
                            const size = readByte();
                            if (size === 0) break;
                            for(let i=0; i<size; ++i) lzwData.push(data[pos++]);
                        }
                        
                        const pixelIndices = [];
                        readLZW(minCodeSize, new Uint8Array(lzwData), pixelIndices);

                        const image = {
                            left, top, w, h, pixelIndices,
                            colorTable: ct,
                            delay: gce ? gce.delay : 0,
                            disposalMethod: gce ? gce.disposalMethod : 0,
                            transparentColorIndex: gce ? gce.transparentColorIndex : null,
                        };
                        frames.push(image);
                        gce = null;

                    } else if (blockType === 0x21) { // Extension
                        const extType = readByte();
                        if (extType === 0xF9) { // Graphic Control Extension
                            readByte(); // block size
                            const packed = readByte();
                            const transparentFlag = (packed & 1) !== 0;
                            gce = {
                                disposalMethod: (packed >> 2) & 7,
                                delay: readUInt16(),
                                transparentColorIndex: transparentFlag ? readByte() : null,
                            };
                            pos++; // skip block terminator
                        } else if (extType === 0xFF) { // Application Extension
                           readByte(); // block size
                           if (readString(11) === 'NETSCAPE2.0') {
                               readByte(); // sub-block size
                               pos++; // always 1
                               loopCount = readUInt16();
                               readByte(); // block terminator
                           } else {
                               while(true) {
                                   const size = readByte(); if (size === 0) break;
                                   pos += size;
                               }
                           }
                        } else {
                             while(true) {
                                const size = readByte(); if (size === 0) break;
                                pos += size;
                            }
                        }
                    } else if (blockType === 0x3B) { // Trailer
                        break;
                    } else {
                        // Unknown block, ignore.
                    }
                }
                return { width, height, frames, loopCount };
            };
            // END OF INLINED GIF PARSER


            // Monkey-patch FieldImage to vertically align icons better.
            const originalInitView = Blockly.FieldImage.prototype.initView;
            Blockly.FieldImage.prototype.initView = function() {
                originalInitView.call(this);
                const yOffset = 3; // Pixels to shift down for better alignment
                this.imageElement_.setAttribute('transform', `translate(0, ${yOffset})`);
            };

            const stageArea = document.getElementById('stage-area');
            const containerWrapper = document.getElementById('container-wrapper');
            const addSpriteButton = document.getElementById('add-sprite-button');
            const spritesList = document.getElementById('sprites-list');
            
            const addBackdropButton = document.getElementById('add-backdrop-button');
            const backdropsList = document.getElementById('backdrops-list');
            const backgroundGallery = document.getElementById('background-gallery');
            const closeGalleryButton = document.getElementById('close-gallery-button');
            const thumbnailsGrid = document.getElementById('thumbnails-grid');
            
            const spriteGallery = document.getElementById('sprite-gallery');
            const closeSpriteGalleryButton = document.getElementById('close-sprite-gallery-button');
            const spriteThumbnailsGrid = document.getElementById('sprite-thumbnails-grid');
            
            const fullscreenButton = document.getElementById('fullscreen-button');
            const enterFullscreenIcon = document.getElementById('enter-fullscreen-icon');
            const exitFullscreenIcon = document.getElementById('exit-fullscreen-icon');
            
            // Project Save/Load elements
            const saveButton = document.getElementById('save-button');
            const loadButton = document.getElementById('load-button');
            const loadInput = document.getElementById('load-input');

            // Sprite Properties Panel elements
            const propertiesPanel = document.getElementById('sprite-properties-panel');
            const propName = document.getElementById('prop-name');
            const propX = document.getElementById('prop-x');
            const propY = document.getElementById('prop-y');
            const propShow = document.getElementById('prop-show');
            const propHide = document.getElementById('prop-hide');
            const propSize = document.getElementById('prop-size');
            const propDirection = document.getElementById('prop-direction');
            const propRotationAllAround = document.getElementById('rotation-all-around');
            const propRotationLeftRight = document.getElementById('rotation-left-right');
            const propRotationDontRotate = document.getElementById('rotation-dont-rotate');
            
            // Angle Picker elements
            const anglePickerWidget = document.getElementById('angle-picker-widget');
            const anglePickerDial = document.getElementById('angle-picker-dial');
            const anglePickerHandle = document.getElementById('angle-picker-handle');
            
            // GIF Animation Panel elements
            const gifAnimationPanel = document.getElementById('gif-animation-panel');
            const gifPlayPauseBtn = document.getElementById('gif-play-pause-btn');
            const gifPlayIcon = document.getElementById('gif-play-icon');
            const gifPauseIcon = document.getElementById('gif-pause-icon');
            const gifSpeedSlider = document.getElementById('gif-speed-slider');
            const gifSpeedValue = document.getElementById('gif-speed-value');

            const STAGE_WIDTH = 480;
            const STAGE_HEIGHT = 360;

            let workspace;
            let sprites = {};
            let activeSpriteId = null;
            let executionCancelled = false;
            let isLoadingProject = false; // Flag to prevent events during load
            let justDragged = false;
            let dragStartX, dragStartY;
            let collisionState = new Set(); // Stores pairs of collided sprites
            let scriptRunner = null;

            // --- Character Creator Elements ---
            const creatorModal = document.getElementById('character-creator-modal');
            const createSpriteHeaderButton = document.getElementById('create-sprite-header-button');
            const creatorCloseButton = document.getElementById('creator-close-button');
            const creatorSaveButton = document.getElementById('creator-save-button');
            const creatorCategoriesContainer = document.getElementById('creator-categories');
            const creatorPartsGrid = document.getElementById('creator-parts-grid');
            const characterCanvas = document.getElementById('character-canvas');
            const creatorControlsPanel = document.getElementById('creator-controls-panel');
            const selectedPartLabel = document.getElementById('selected-part-label');
            const creatorColorPalette = document.getElementById('creator-color-palette');
            const creatorFlipHButton = document.getElementById('creator-flip-h-button');
            const ctx = characterCanvas.getContext('2d');
            
            let activeCreatorCategory = 'shirt';
            let currentCharacter = {};
            let imageCache = {}; // Caches final Image objects
            let assetCache = {}; // Caches raw SVG text content
            let selectedPartOnCanvas = null; // Will be an object like { category, index? }
            let editingSpriteId = null; // ID of sprite being edited
            
            // State for direct manipulation
            let creatorAction = {
                type: 'none', // 'move', 'resize', 'rotate'
                partSelection: null, // The selection object
                handle: null, // e.g., 'topLeft', 'bottomRight', 'rotate'
                startX: 0,
                startY: 0,
                initialState: {}
            };

            
            // --- Frame-Based Script Execution Engine (like Scratch) ---
            class ScriptRunner {
                constructor() {
                    this.threads = [];
                    this.isRunning = false;
                    log('מנוע ריצה חדש נוצר.');
                }

                add(generator) {
                    this.threads.push(generator);
                    if (!this.isRunning) {
                        this.start();
                    }
                }

                start() {
                    if (this.isRunning) return;
                    this.isRunning = true;
                    executionCancelled = false;
                    log('מנוע ריצה התחיל.');
                }

                stop() {
                    this.isRunning = false;
                    this.threads = [];
                    executionCancelled = true;
                    log('מנוע ריצה נעצר.');
                }

                tick() {
                    if (!this.isRunning) return;

                    for (let i = this.threads.length - 1; i >= 0; i--) {
                        const generator = this.threads[i];
                        const result = generator.next();
                        if (result.done) {
                            this.threads.splice(i, 1);
                        }
                    }
                    
                    if (this.threads.length === 0) {
                        log('כל התסריטים הסתיימו.');
                        this.stop(); 
                    }
                }
            }

            // Custom field for messages
            const messageOptions = [
                [{
                    src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="red"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>',
                    width: 24, height: 24, alt: 'לב אדום'
                }, 'red_heart'],
                [{
                    src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="blue"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>',
                    width: 24, height: 24, alt: 'כוכב כחול'
                }, 'blue_star'],
                [{
                    src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="green"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>',
                    width: 24, height: 24, alt: 'משולש ירוק'
                }, 'green_triangle'],
                [{
                    src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="yellow" stroke="black" stroke-width="0.5"><circle cx="12" cy="12" r="10"/></svg>',
                    width: 24, height: 24, alt: 'עיגול צהוב'
                }, 'yellow_circle'],
                [{
                    src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="purple"><path d="M3 3h18v18H3z"/></svg>',
                    width: 24, height: 24, alt: 'ריבוע סגול'
                }, 'purple_square'],
                [{
                    src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="orange"><path d="M12 2.5l7.5 5.5-3 9H7.5l-3-9L12 2.5z"/></svg>',
                    width: 24, height: 24, alt: 'מחומש כתום'
                }, 'orange_pentagon']
            ];

            class FieldMessage extends Blockly.FieldDropdown {
                constructor() {
                    super(FieldMessage.getOptions);
                }

                static getOptions() {
                    return messageOptions;
                }
                
                initView() {
                    super.initView();
                    this.imageElement_ = Blockly.utils.dom.createSvgElement('image',
                        { 'height': '24px', 'width': '24px' },
                        this.fieldGroup_
                    );
                    this.updateImageView_();
                }

                doValueUpdate_(newValue) {
                    super.doValueUpdate_(newValue);
                    this.updateImageView_();
                }
                
                updateImageView_() {
                    if (this.value_ && this.imageElement_) {
                        const options = this.getOptions(false);
                        const selectedOption = options.find(opt => opt[1] === this.value_);
                        if (selectedOption) {
                            this.imageElement_.setAttributeNS(
                                'http://www.w3.org/1999/xlink',
                                'xlink:href',
                                selectedOption[0].src
                            );
                            if(this.textElement_) {
                            this.textElement_.style.display = 'none';
                            }
                        }
                    }
                }
            }
            Blockly.fieldRegistry.register('field_message', FieldMessage);
            
            const log = (message) => {
                console.log(message);
            };

            const getActiveSprite = () => sprites[activeSpriteId] || null;
            
            // This global function allows block code to update the panel
            window.updateActiveSpritePanel = () => {
                if (activeSpriteId && sprites[activeSpriteId]) {
                    updatePropertiesPanel();
                }
            }

            // Centralized backdrop switching logic
            window.switchBackdrop = (url) => {
                if (!url || url === 'NONE') return;
                try {
                    stageArea.style.backgroundImage = `url("${url}")`;

                    document.querySelectorAll('.backdrop-card').forEach(card => card.classList.remove('selected'));
                    
                    const allCards = Array.from(document.querySelectorAll('.backdrop-card'));
                    const cardToSelect = allCards.find(card => card.dataset.url === url);
                    
                    if (cardToSelect) {
                        cardToSelect.classList.add('selected');
                    }
                    log(`הרקע הוחלף ל: ${url}`);
                } catch (e) {
                    console.error("Failed to switch backdrop:", e);
                }
            };
            
            const updateSpriteAppearance = (spriteId) => {
                const spriteData = sprites[spriteId];
                if (!spriteData) return;

                const container = document.getElementById(`container-${spriteData.id}`);
                const wrapper = container.querySelector('.sprite-wrapper');
                
                if (container && wrapper) {
                    const rect = stageArea.getBoundingClientRect();
                    const stageToSpriteX = STAGE_WIDTH / rect.width;
                    const stageToSpriteY = STAGE_HEIGHT / rect.height;

                    const stageX = spriteData.x / stageToSpriteX;
                    const stageY = -spriteData.y / stageToSpriteY;
                    
                    const baseSize = 160;
                    const newSize = baseSize * (spriteData.size / 100);

                    // --- Rotation Logic ---
                    let rotationTransform = '';
                    switch(spriteData.rotationStyle) {
                        case 'left-right':
                            const normalizedDir = ((spriteData.direction % 360) + 360) % 360;
                            // The sprite should face right for directions 0-179 and left for 180-359.
                            const isFlipped = normalizedDir >= 180;
                            rotationTransform = isFlipped ? 'scaleX(-1)' : 'scaleX(1)';
                            break;
                        case 'dont-rotate':
                            rotationTransform = ''; // No rotation at all
                            break;
                        case 'all-around':
                        default:
                            rotationTransform = `rotate(${spriteData.direction - 90}deg)`;
                            break;
                    }
                    // --- End Rotation Logic ---

                    // Apply styles to the single wrapper
                    wrapper.style.width = `${newSize}px`;
                    wrapper.style.height = `${newSize}px`;
                    wrapper.style.opacity = spriteData.opacity;
                    wrapper.style.transform = `translate(-50%, -50%) ${rotationTransform}`;
                    
                    // Position the main container which holds the wrapper
                    container.style.transform = `translate(${stageX}px, ${stageY}px)`;
                    
                    // After any visual update, check for collisions
                    checkCollisions();
                }
            };
            
            const updatePropertiesPanel = () => {
                const sprite = getActiveSprite();
                if (sprite) {
                    propertiesPanel.classList.remove('hidden');
                    
                    propName.value = sprite.name;
                    propX.value = Math.round(sprite.x);
                    propY.value = Math.round(sprite.y);
                    propSize.value = sprite.size;
                    propDirection.value = sprite.direction;

                    if (sprite.opacity === 1) {
                        propShow.classList.add('active');
                        propHide.classList.remove('active');
                    } else {
                        propShow.classList.remove('active');
                        propHide.classList.add('active');
                    }
                    
                    // Update rotation style buttons
                    propRotationAllAround.classList.toggle('active', sprite.rotationStyle === 'all-around');
                    propRotationLeftRight.classList.toggle('active', sprite.rotationStyle === 'left-right');
                    propRotationDontRotate.classList.toggle('active', sprite.rotationStyle === 'dont-rotate');

                    if (sprite.isGif && sprite.animation) {
                        gifAnimationPanel.classList.remove('hidden');
                        gifSpeedSlider.value = sprite.gifSpeed;
                        gifSpeedValue.textContent = `${Number(sprite.gifSpeed).toFixed(1)}x`;
                        const isPlaying = sprite.animation.previewIsPlaying;
                        gifPlayIcon.classList.toggle('hidden', isPlaying);
                        gifPauseIcon.classList.toggle('hidden', !isPlaying);
                    } else {
                        gifAnimationPanel.classList.add('hidden');
                    }

                } else {
                    propertiesPanel.classList.add('hidden');
                }
            };

            const createNewSprite = (name, imageUrl, initialX = 0, initialY = 0, isCustom = false, characterData = null, gifSpeed = 1.0) => {
                const id = `sprite-${Date.now()}`;
                const isGif = imageUrl.toLowerCase().endsWith('.gif') || imageUrl.startsWith('data:image/gif');

                const spriteData = {
                    id,
                    name,
                    imageUrl,
                    x: initialX,
                    y: initialY,
                    direction: 90,
                    opacity: 1,
                    size: 100,
                    rotationStyle: 'all-around',
                    workspaceXml: null,
                    isCustom: isCustom,
                    characterData: characterData,
                    isGif: isGif,
                    animation: null,
                    gifSpeed: gifSpeed
                };
                
                sprites[id] = spriteData;

                const spriteCard = document.createElement('div');
                spriteCard.classList.add('sprite-card');
                spriteCard.dataset.spriteId = id;
                spriteCard.innerHTML = `
                    <img src="${imageUrl}" alt="${name}">
                    <div class="delete-button">X</div>
                     ${isCustom ? `
                        <div class="edit-button" title="ערוך דמות">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" />
                                <path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" />
                            </svg>
                        </div>` : ''}
                `;
                spritesList.appendChild(spriteCard);
                
                if (isCustom) {
                    spriteCard.querySelector('.edit-button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        openCreatorForEdit(id);
                    });
                }

                const spriteContainer = document.createElement('div');
                spriteContainer.id = `container-${id}`;
                spriteContainer.classList.add('sprite-container');

                const mainSprite = document.createElement('div');
                mainSprite.classList.add('sprite-wrapper');
                mainSprite.id = id;
                mainSprite.innerHTML = `
                    <img src="${imageUrl}" alt="${name}">
                    <canvas class="hidden absolute top-0 left-0 w-full h-full"></canvas>
                    <div class="speech-bubble"></div>
                `;
                
                spriteContainer.appendChild(mainSprite);
                stageArea.appendChild(spriteContainer);

                if (isGif) {
                    loadGifData(spriteData);
                }
                
                const wrapper = spriteContainer.querySelector('.sprite-wrapper');
                wrapper.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (justDragged) return;
                    handleSpriteClick(id);
                });
                wrapper.addEventListener('mousedown', (e) => startDrag(e, id));
                wrapper.addEventListener('touchstart', (e) => startDrag(e, id));
                
                spriteCard.addEventListener('click', () => {
                    setActiveSprite(id);
                });
                spriteCard.querySelector('.delete-button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSprite(id);
                });

                setActiveSprite(id);
                updateSpriteAppearance(id);
                return spriteData;
            };

            const deleteSprite = (id) => {
                document.getElementById(`container-${id}`)?.remove();
                document.querySelector(`.sprite-card[data-sprite-id="${id}"]`)?.remove();
                
                delete sprites[id];

                if (activeSpriteId === id) {
                    activeSpriteId = null;
                    workspace.clear();
                    const firstSpriteId = Object.keys(sprites)[0];
                    if (firstSpriteId) {
                        setActiveSprite(firstSpriteId);
                    } else {
                        updatePropertiesPanel();
                    }
                }
                log(`הדמות ${id} נמחקה.`);
            };
            
            const setActiveSprite = (spriteId) => {
                if (scriptRunner && scriptRunner.isRunning || activeSpriteId === spriteId) return;

                // 1. Save current workspace
                if (activeSpriteId && sprites[activeSpriteId]) {
                    const oldDom = Blockly.Xml.workspaceToDom(workspace);
                    sprites[activeSpriteId].workspaceXml = Blockly.Xml.domToText(oldDom);
                }

                // 2. Deselect old card
                if (activeSpriteId) {
                    const prevCard = document.querySelector(`.sprite-card[data-sprite-id="${activeSpriteId}"]`);
                    if (prevCard) {
                        prevCard.classList.remove('selected');
                    }
                }

                // 3. Set new active sprite
                activeSpriteId = spriteId;

                // 4. Clear and load new workspace
                workspace.clear();
                const newSprite = sprites[spriteId];
                if (newSprite && newSprite.workspaceXml) {
                    try {
                        const newDom = Blockly.Xml.textToDom(newSprite.workspaceXml);
                        Blockly.Xml.domToWorkspace(newDom, workspace);
                    } catch (e) {
                        console.error("Error loading workspace XML:", e);
                        workspace.clear(); // Clear on error to avoid broken state
                    }
                }

                // 5. Select new card
                const newCard = document.querySelector(`.sprite-card[data-sprite-id="${spriteId}"]`);
                if (newCard) {
                    newCard.classList.add('selected');
                }
                
                // 6. Update properties panel
                updatePropertiesPanel();

                log(`הדמות הפעילה היא: ${newSprite.name}`);
            };

            let isDragging = false;
            let dragSpriteId = null;
            let initialMouseX, initialMouseY, initialSpriteX, initialSpriteY;

            const getPointerPosition = (e) => {
                if (e.touches && e.touches.length > 0) {
                    return { x: e.touches[0].clientX, y: e.touches[0].clientY };
                }
                return { x: e.clientX, y: e.clientY };
            };
            
            const startDrag = (e, spriteId) => {
                e.preventDefault();
                isDragging = true;
                dragSpriteId = spriteId;
                const spriteData = sprites[dragSpriteId];

                setActiveSprite(spriteId);
                const { x, y } = getPointerPosition(e);
                dragStartX = x;
                dragStartY = y;
                initialMouseX = x;
                initialMouseY = y;
                initialSpriteX = spriteData.x;
                initialSpriteY = spriteData.y;
                document.getElementById(spriteId).style.transition = 'none';
                log('הדמות נתפסה לגרירה.');
            };

            const drag = (e) => {
                if (isDragging && dragSpriteId) {
                    const spriteData = sprites[dragSpriteId];
                    const { x, y } = getPointerPosition(e);
                    const deltaX = x - initialMouseX;
                    const deltaY = y - initialMouseY;
                    
                    const rect = stageArea.getBoundingClientRect();
                    const scaleX = STAGE_WIDTH / rect.width;
                    const scaleY = STAGE_HEIGHT / rect.height;

                    spriteData.x = initialSpriteX + deltaX * scaleX;
                    spriteData.y = initialSpriteY - deltaY * scaleY;
                    
                    updateSpriteAppearance(dragSpriteId);
                    updatePropertiesPanel();
                }
            };

            const endDrag = (e) => {
                if (isDragging && dragSpriteId) {
                     const pointer = e.changedTouches ? e.changedTouches[0] : e;
                    const deltaX = pointer.clientX - dragStartX;
                    const deltaY = pointer.clientY - dragStartY;
                    const distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);

                    if (distance > 5) { // Threshold to differentiate click from drag
                        justDragged = true;
                        setTimeout(() => { justDragged = false; }, 50);
                    } else {
                        justDragged = false;
                    }

                    const spriteData = sprites[dragSpriteId];
                    document.getElementById(dragSpriteId).style.transition = 'transform 0.5s ease-out';
                    updatePropertiesPanel(); // Final update
                    log(`הדמות נגררה למיקום חדש (x: ${spriteData.x.toFixed(0)}, y: ${spriteData.y.toFixed(0)})`);
                }
                isDragging = false;
                dragSpriteId = null;
            };

            stageArea.addEventListener('mousemove', drag);
            stageArea.addEventListener('touchmove', drag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            document.addEventListener('touchcancel', endDrag);

            window.addEventListener('resize', () => {
                Object.keys(sprites).forEach(updateSpriteAppearance);
                Blockly.svgResize(workspace);
            });
            
            function positionNumberPad(field) {
                const numberPad = document.getElementById('number-pad-container');
                if (!field || numberPad.style.display !== 'block') {
                    return;
                }

                // Make pad temporarily visible but transparent to measure its dimensions
                numberPad.style.visibility = 'hidden';
                const padRect = numberPad.getBoundingClientRect();
                
                const blockSvg = field.getSourceBlock().getSvgRoot();
                const blockBounds = blockSvg.getBoundingClientRect();

                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const margin = 5; // Margin from screen edges

                // --- Vertical Positioning ---
                let finalTop;
                // Try positioning below first
                if (blockBounds.bottom + padRect.height + margin < viewportHeight) {
                    finalTop = blockBounds.bottom + margin;
                } 
                // If not enough space below, try positioning above
                else if (blockBounds.top - padRect.height - margin > 0) {
                    finalTop = blockBounds.top - padRect.height - margin;
                } 
                // If no space above either, position it as best as possible (e.g., at the top)
                else {
                    finalTop = margin;
                }

                // --- Horizontal Positioning ---
                let finalLeft;
                // Start by aligning with the block's left edge
                finalLeft = blockBounds.left;
                
                // If it overflows right, align to the right edge of the screen
                if (finalLeft + padRect.width + margin > viewportWidth) {
                     finalLeft = viewportWidth - padRect.width - margin;
                }
                
                // Ensure it doesn't go off the left edge
                if (finalLeft < margin) {
                    finalLeft = margin;
                }

                numberPad.style.top = `${finalTop}px`;
                numberPad.style.left = `${finalLeft}px`;
                
                numberPad.style.visibility = 'visible';
            }
            
            // Custom Field for Number Pad
            class FieldCustomNumber extends Blockly.FieldNumber {
                constructor(value, min, max, precision, validator) {
                    super(value, min, max, precision, validator);
                }

                showEditor_() {
                    const numberPad = document.getElementById('number-pad-container');
                    const numberPadDisplay = document.getElementById('number-pad-display');
                    
                    numberPad.currentField = this;
                    numberPadDisplay.textContent = this.getValue() || '0';

                    // Show pad to start calculations
                    numberPad.style.display = 'block';
                    
                    positionNumberPad(this);
                }
            }
            Blockly.fieldRegistry.register('field_custom_number', FieldCustomNumber);
            
            // Redefine standard math_number block to use our custom field
            Blockly.Blocks['math_number'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new FieldCustomNumber(0), 'NUM');
                    this.setOutput(true, 'Number');
                    this.setColour("#40BF4A");
                    this.setTooltip("A number.");
                    this.setHelpUrl("%{BKY_MATH_NUMBER_HELPURL}");
                }
            };

            Blockly.Blocks['event_when_flag_clicked'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon//flag.svg", 35, 35, { alt: "green flag", flipRtl: "false" }))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setNextStatement(true, null);
                    this.setColour("#FFE75A");
                    this.setTooltip("התחל את התסריט כאשר הדגל הירוק נלחץ.");
                    this.setHelpUrl("");
                }
            };
            Blockly.JavaScript['event_when_flag_clicked'] = function(block) { return ''; };

            Blockly.Blocks['event_when_sprite_clicked'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/whenprees.svg", 35, 35, "*"))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setNextStatement(true, null);
                    this.setColour("#FFE75A");
                    this.setTooltip("התחל את התסריט כאשר לוחצים על הדמות.");
                    this.setHelpUrl("");
                }
            };
            Blockly.JavaScript['event_when_sprite_clicked'] = function(block) { return ''; };

            Blockly.Blocks['event_when_key_pressed'] = {
                init: function() {
                    const keyOptions = [
                        [
                            {
                                src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="48" height="24" viewBox="0 0 48 24"><rect x="1" y="1" width="46" height="22" rx="4" fill="%23fff" stroke="%23555" stroke-width="2"/><text x="24" y="16" font-family="Arial" font-size="12" text-anchor="middle" fill="%23000">רווח</text></svg>',
                                width: 48,
                                height: 24,
                                alt: 'רווח'
                            },
                            'SPACE'
                        ],
                        [
                             {
                                src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="4" fill="%23fff" stroke="%23555" stroke-width="2"/><path d="M12 8l-4 4h8z" fill="%23555"/></svg>',
                                width: 24,
                                height: 24,
                                alt: 'חץ למעלה'
                            },
                            'UP'
                        ],
                        [
                            {
                                src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="4" fill="%23fff" stroke="%23555" stroke-width="2"/><path d="M12 16l4-4H8z" fill="%23555"/></svg>',
                                width: 24,
                                height: 24,
                                alt: 'חץ למטה'
                            },
                            'DOWN'
                        ],
                        [
                            {
                                src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="4" fill="%23fff" stroke="%23555" stroke-width="2"/><path d="M14 12l-4 4V8z" fill="%23555"/></svg>',
                                width: 24,
                                height: 24,
                                alt: 'חץ ימינה'
                            },
                            'RIGHT'
                        ],
                        [
                            {
                                src: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="4" fill="%23fff" stroke="%23555" stroke-width="2"/><path d="M10 12l4-4v8z" fill="%23555"/></svg>',
                                width: 24,
                                height: 24,
                                alt: 'חץ שמאלה'
                            },
                            'LEFT'
                        ]
                    ];
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/keyboard.svg", 35, 35, { alt: "keyboard icon", flipRtl: "false" }))
                        .appendField(new Blockly.FieldDropdown(keyOptions), "KEY");
                    this.setNextStatement(true, null);
                    this.setColour("#FFE75A");
                    this.setTooltip("הפעל את התסריט כאשר המקש הנבחר נלחץ.");
                    this.setHelpUrl("");
                }
            };
            Blockly.JavaScript['event_when_key_pressed'] = function(block) { return ''; };
            
            Blockly.Blocks['event_when_bump'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/collision.svg", 35, 35, "*"))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setNextStatement(true, null);
                    this.setColour("#FFE75A");
                    this.setTooltip("התחל את התסריט כאשר דמות זו נוגעת בדמות אחרת.");
                }
            };
            Blockly.JavaScript['event_when_bump'] = function(block) { return ''; };


            Blockly.Blocks['event_broadcast'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/send.svg", 35, 35, "*"))
                        .appendField(new FieldMessage(), 'MESSAGE')
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#FFE75A");
                    this.setTooltip("שולח מסר לכל הדמויות.");
                }
            };

            Blockly.JavaScript['event_broadcast'] = function(block) {
                const message = block.getFieldValue('MESSAGE');
                return `
                    log('משדר מסר: ${message}');
                    const event = new CustomEvent('kidi-broadcast', { detail: { message: '${message}' } });
                    window.dispatchEvent(event);
                    yield;
                `;
            };

            Blockly.Blocks['event_when_broadcast_received'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/receive.svg", 35, 35, "*"))
                        .appendField(new FieldMessage(), 'MESSAGE')
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setNextStatement(true, null);
                    this.setColour("#FFE75A");
                    this.setTooltip("מתחיל תסריט כאשר מתקבל מסר ספציפי.");
                }
            };
            Blockly.JavaScript['event_when_broadcast_received'] = function(block) { return ''; };

            Blockly.Blocks['motion_move_steps'] = {
                init: function() {
                    this.appendValueInput("STEPS").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT)
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon//walk.svg", 34, 34, "*"))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#4C97FF");
                    this.setTooltip("הזז את הדמות בכיוון שהיא פונה.");
                }
            };
            Blockly.JavaScript['motion_move_steps'] = function(block) {
                const steps = Blockly.JavaScript.valueToCode(block, 'STEPS', Blockly.JavaScript.ORDER_ATOMIC) || '10';
                return `
                    if (sprite) {
                        const radians = sprite.direction * Math.PI / 180;
                        sprite.x += (${steps}) * Math.sin(radians);
                        sprite.y += (${steps}) * Math.cos(radians);
                        
                        const halfWidth = ${STAGE_WIDTH / 2};
                        const halfHeight = ${STAGE_HEIGHT / 2};
                        const spriteLogicalWidth = 160 * (sprite.size / 100);
                        const spriteLogicalHeight = 160 * (sprite.size / 100);
                        const spriteHalfWidth = spriteLogicalWidth / 2;
                        const spriteHalfHeight = spriteLogicalHeight / 2;

                        if (sprite.x - spriteHalfWidth > halfWidth) {
                            sprite.x = -halfWidth - spriteHalfWidth;
                        }
                        if (sprite.x + spriteHalfWidth < -halfWidth) {
                            sprite.x = halfWidth + spriteHalfWidth;
                        }
                        if (sprite.y - spriteHalfHeight > halfHeight) {
                            sprite.y = -halfHeight - spriteHalfHeight;
                        }
                        if (sprite.y + spriteHalfHeight < -halfHeight) {
                            sprite.y = halfHeight + spriteHalfHeight;
                        }

                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' זזה ' + (${steps}) + ' צעדים.');
                    }
                    yield;
                `;
            };
            Blockly.Blocks['motion_turn_right_degrees'] = {
                init: function() {
                    this.appendValueInput("DEGREES").setCheck("Number")
                        .appendField(new Blockly.FieldImage("https://github.com/codejredu/test/raw/main/assets/blocklyicon/right.png", 34, 34, { alt: "turn right icon", flipRtl: "false" }))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#4C97FF");
                    this.setTooltip("סובב את הדמות ימינה.");
                }
            };
            Blockly.JavaScript['motion_turn_right_degrees'] = function(block) {
                const degrees = Blockly.JavaScript.valueToCode(block, 'DEGREES', Blockly.JavaScript.ORDER_ATOMIC) || '15';
                return `
                    if (sprite) {
                         sprite.direction += (${degrees});
                         updateSpriteAppearance(sprite.id);
                         window.updateActiveSpritePanel();
                        log(sprite.name + ' הסתובבה ימינה ב-' + (${degrees}) + ' מעלות.');
                    }
                    yield;
                `;
            };
            Blockly.Blocks['motion_turn_left_degrees'] = {
                init: function() {
                    this.appendValueInput("DEGREES").setCheck("Number")
                        .appendField(new Blockly.FieldImage("https://github.com/codejredu/test/raw/main/assets/blocklyicon/left.png", 34, 34, { alt: "turn left icon", flipRtl: "false" }))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#4C97FF");
                    this.setTooltip("סובב את הדמות שמאלה.");
                }
            };
            Blockly.JavaScript['motion_turn_left_degrees'] = function(block) {
                const degrees = Blockly.JavaScript.valueToCode(block, 'DEGREES', Blockly.JavaScript.ORDER_ATOMIC) || '15';
                return `
                    if (sprite) {
                        sprite.direction -= (${degrees});
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' הסתובבה שמאלה ב-' + (${degrees}) + ' מעלות.');
                    }
                    yield;
                `;
            };
            
            Blockly.Blocks['motion_set_direction'] = {
                init: function() {
                    const angleValidator = (newValue) => {
                         if (getActiveSprite()) {
                            let sprite = getActiveSprite();
                            sprite.direction = Number(newValue);
                            updateSpriteAppearance(sprite.id);
                            updatePropertiesPanel();
                        }
                        return newValue;
                    };

                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/compass.svg", 34, 34, { alt: "compass icon", flipRtl: "false" }))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0')
                        .appendField(new Blockly.FieldAngle('90', angleValidator), 'DEGREES');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#4C97FF");
                    this.setTooltip("קבע את כיוון הדמות.");
                }
            };
            Blockly.JavaScript['motion_set_direction'] = function(block) {
                const degrees = block.getFieldValue('DEGREES');
                return `
                    if (sprite) {
                        sprite.direction = ${degrees};
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' קבעה כיוון ל-' + ${degrees} + ' מעלות.');
                    }
                    yield;
                `;
            };
            
            Blockly.Blocks['looks_say_for_secs'] = {
                init: function() {
                    this.appendValueInput("MESSAGE").setCheck("String").setAlign(Blockly.ALIGN_RIGHT)
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/say.png", 34, 34, { alt: "say icon", flipRtl: "false" }));
                    this.appendValueInput("SECS").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT);
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("גרום לדמות לומר הודעה למשך מספר שניות.");
                }
            };
            Blockly.JavaScript['looks_say_for_secs'] = function(block) {
                const message = Blockly.JavaScript.valueToCode(block, 'MESSAGE', Blockly.JavaScript.ORDER_ATOMIC) || "''";
                const secs = Blockly.JavaScript.valueToCode(block, 'SECS', Blockly.JavaScript.ORDER_ATOMIC) || '2';
                return `
                    if (sprite) {
                        const spriteEl = document.getElementById(sprite.id);
                        if (spriteEl) {
                            const bubble = spriteEl.querySelector('.speech-bubble');
                            bubble.textContent = ${message};
                            bubble.classList.add('visible');
                            log(sprite.name + ' אומרת: ' + ${message});
                            
                            const endTime = Date.now() + (${secs}) * 1000;
                            while (Date.now() < endTime) {
                                if (getExecutionCancelled()) break;
                                yield;
                            }

                            if (!getExecutionCancelled()) {
                                 bubble.classList.remove('visible');
                            }
                        }
                    }
                `;
            };
            Blockly.Blocks['looks_say'] = {
                init: function() {
                    this.appendValueInput("MESSAGE").setCheck("String").setAlign(Blockly.ALIGN_RIGHT)
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/say.png", 34, 34, { alt: "say icon", flipRtl: "false" }));
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("גרום לדמות לומר הודעה.");
                }
            };
            Blockly.JavaScript['looks_say'] = function(block) {
                const message = Blockly.JavaScript.valueToCode(block, 'MESSAGE', Blockly.JavaScript.ORDER_ATOMIC) || "''";
                return `
                    if (sprite) {
                        const spriteEl = document.getElementById(sprite.id);
                        if (spriteEl) {
                           const bubble = spriteEl.querySelector('.speech-bubble');
                           bubble.textContent = ${message};
                           bubble.classList.add('visible');
                           log(sprite.name + ' אומרת: ' + ${message});
                        }
                    }
                `;
            };
            Blockly.Blocks['looks_show'] = {
                init: function() {
                    this.appendDummyInput().appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/show.png", 34, 34, { alt: "show icon", flipRtl: "false" })).appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("הצג את הדמות.");
                }
            };
            Blockly.JavaScript['looks_show'] = function(block) {
                return `
                    if (sprite) {
                        sprite.opacity = 1;
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' הוצגה.');
                    }
                    yield;
                `;
            };
            Blockly.Blocks['looks_hide'] = {
                init: function() {
                    this.appendDummyInput().appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/hide.png", 34, 34, { alt: "hide icon", flipRtl: "false" })).appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("הסתר את הדמות.");
                }
            };
            Blockly.JavaScript['looks_hide'] = function(block) {
                return `
                    if (sprite) {
                        sprite.opacity = 0;
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' הוסתרה.');
                    }
                    yield;
                `;
            };

            Blockly.Blocks['looks_grow'] = {
                init: function() {
                    this.appendValueInput("SIZE")
                        .setCheck("Number")
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/increase.svg", 34, 34, "*"));
                    this.appendDummyInput().appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("הגדל את הדמות.");
                }
            };
            Blockly.JavaScript['looks_grow'] = function(block) {
                const size = Blockly.JavaScript.valueToCode(block, 'SIZE', Blockly.JavaScript.ORDER_ATOMIC) || '10';
                return `
                    if (sprite) {
                        sprite.size += Number(${size});
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' גדלה לגודל ' + sprite.size);
                    }
                    yield;
                `;
            };
            
            Blockly.Blocks['looks_shrink'] = {
                init: function() {
                    this.appendValueInput("SIZE")
                        .setCheck("Number")
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/decrease.svg", 34, 34, "*"));
                    this.appendDummyInput().appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("הקטן את הדמות.");
                }
            };
            Blockly.JavaScript['looks_shrink'] = function(block) {
                const size = Blockly.JavaScript.valueToCode(block, 'SIZE', Blockly.JavaScript.ORDER_ATOMIC) || '10';
                return `
                    if (sprite) {
                        sprite.size = Math.max(5, sprite.size - Number(${size})); // Don't let size go below 5
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' קטנה לגודל ' + sprite.size);
                    }
                    yield;
                `;
            };

            Blockly.Blocks['looks_set_size'] = {
                init: function() {
                    this.appendValueInput("SIZE")
                        .setCheck("Number")
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/equal.svg", 34, 34, "*"));
                    this.appendDummyInput().appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("קובע את גודל הדמות באחוזים.");
                }
            };
            Blockly.JavaScript['looks_set_size'] = function(block) {
                const size = Blockly.JavaScript.valueToCode(block, 'SIZE', Blockly.JavaScript.ORDER_ATOMIC) || '100';
                return `
                    if (sprite) {
                        sprite.size = Math.max(5, Number(${size})); // Don't let size go below 5
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' קבע גודל ל-' + sprite.size);
                    }
                    yield;
                `;
            };

            // Custom field for backdrop selection
            class FieldBackdrop extends Blockly.FieldDropdown {
                constructor() {
                    // We pass a function that will be called by Blockly when it needs the options.
                    super(FieldBackdrop.generateOptions);
                }

                static generateOptions() {
                    const backdropElements = document.querySelectorAll('#backdrops-list .backdrop-card');
                    if (!backdropElements || backdropElements.length === 0) {
                        return [['(אין רקעים)', 'NONE']];
                    }
                    
                    const options = Array.from(backdropElements).map((card) => {
                        const url = card.dataset.url;
                        const name = url.substring(url.lastIndexOf('/') + 1).replace(/\.(svg|png|jpg|jpeg)$/i, '');
                        return [
                            {
                                src: url,
                                width: 48, // Thumbnail width
                                height: 36, // Thumbnail height
                                alt: name,
                            },
                            url // The value for this option is the URL string
                        ];
                    });
                    
                    return options.length > 0 ? options : [['(אין רקעים)', 'NONE']];
                }

                // Override to show image in the block itself
                initView() {
                    super.initView();
                    this.imageElement_ = Blockly.utils.dom.createSvgElement('image', {
                        'height': '36px',
                        'width': '48px',
                        'y': -10, // Adjust vertical position
                        'x': 5
                    }, this.fieldGroup_);
                    this.updateImageView_();
                }

                doValueUpdate_(newValue) {
                    super.doValueUpdate_(newValue);
                    this.updateImageView_();
                }

                updateImageView_() {
                    if (this.value_ && this.imageElement_ && this.value_ !== 'NONE') {
                        this.imageElement_.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', this.value_);
                         if (this.textElement_) {
                           this.textElement_.style.display = 'none';
                        }
                    } else if (this.imageElement_) {
                        this.imageElement_.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '');
                         if (this.textElement_) {
                           this.textElement_.style.display = 'block';
                        }
                    }
                }
            }
            Blockly.fieldRegistry.register('field_backdrop', FieldBackdrop);

            Blockly.Blocks['looks_switch_backdrop'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/bg/bgimage.svg", 34, 34, "*"))
                        .appendField(new FieldBackdrop(), 'BACKDROP');
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#9966FF");
                    this.setTooltip("משנה את הרקע של הבמה.");
                }
            };
             Blockly.JavaScript['looks_switch_backdrop'] = function(block) {
                const backdropUrl = block.getFieldValue('BACKDROP');
                if (backdropUrl && backdropUrl !== 'NONE') {
                    const safeUrl = backdropUrl.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
                    return `
                        window.switchBackdrop('${safeUrl}');
                        yield;
                    `;
                }
                return ''; // Do nothing if no backdrop is selected
            };


            
            Blockly.Blocks['control_wait_secs'] = {
                init: function() {
                    this.appendValueInput("SECS").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT).appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/wait.svg", 34, 34, "*"));
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#FF6B1A");
                    this.setTooltip("המתן למשך מספר שניות.");
                }
            };
            Blockly.JavaScript['control_wait_secs'] = function(block) {
                const secs = Blockly.JavaScript.valueToCode(block, 'SECS', Blockly.JavaScript.ORDER_ATOMIC) || '1';
                return `
                    log('המתנה של ' + (${secs}) + ' שניות...');
                    const endTime = Date.now() + (${secs}) * 1000;
                    while (Date.now() < endTime) {
                        if (getExecutionCancelled()) break;
                        yield;
                    }
                `;
            };

            Blockly.Blocks['control_repeat_times'] = {
                init: function() {
                    this.appendValueInput("TIMES")
                        .setCheck("Number")
                        .appendField('\u00A0\u00A0\u00A0\u00A0')
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/repeat.svg", 24, 24, "*"));
                    this.appendDummyInput().appendField('\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.appendStatementInput("DO").setCheck(null);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#FF6B1A");
                    this.setTooltip("חזור על הבלוקים שבפנים מספר פעמים.");
                }
            };
            Blockly.JavaScript['control_repeat_times'] = function(block) {
                const times = Blockly.JavaScript.valueToCode(block, 'TIMES', Blockly.JavaScript.ORDER_ATOMIC) || '10';
                const branch = Blockly.JavaScript.statementToCode(block, 'DO');
                return `
                    for (let i = 0; i < (${times}); i++) {
                        if (getExecutionCancelled()) break;
                        log('חזרה מספר: ' + (i + 1));
                        ${branch}
                        if (getExecutionCancelled()) break;
                        yield;
                    }
                `;
            };

            Blockly.Blocks['control_forever'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0')
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/forever.svg", 36, 36, "*"));
                    this.appendStatementInput("DO").setCheck(null);
                    this.setPreviousStatement(true, null);
                    this.setColour("#FF6B1A");
                    this.setTooltip("חזור על הבלוקים שבפנים לנצח.");
                }
            };
            Blockly.JavaScript['control_forever'] = function(block) {
                const branch = Blockly.JavaScript.statementToCode(block, 'DO');
                return `
                    while(!getExecutionCancelled()) {
                        ${branch}
                        yield;
                    }
                `;
            };
            Blockly.Blocks['motion_go_to_xy'] = {
                init: function() {
                    this.appendValueInput("X").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT).appendField("x:");
                    this.appendValueInput("Y").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT).appendField("y:");
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#4C97FF");
                    this.setTooltip("הזז את הדמות למיקום ספציפי על הבמה.");
                }
            };
            Blockly.JavaScript['motion_go_to_xy'] = function(block) {
                const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
                const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
                return `
                    if (sprite) {
                        sprite.x = (${x});
                        sprite.y = (${y});
                        updateSpriteAppearance(sprite.id);
                        window.updateActiveSpritePanel();
                        log(sprite.name + ' עברה למיקום: ' + sprite.x.toFixed(0) + ', ' + sprite.y.toFixed(0));
                    }
                    yield;
                `;
            };
            Blockly.Blocks['motion_glide_to_xy'] = {
                init: function() {
                    this.appendValueInput("SECS").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT).appendField("גלוש");
                    this.appendDummyInput().appendField("שניות למיקום");
                    this.appendValueInput("X").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT).appendField("x:");
                    this.appendValueInput("Y").setCheck("Number").setAlign(Blockly.ALIGN_RIGHT).appendField("y:");
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#4C97FF");
                    this.setTooltip("החלק את הדמות בצורה חלקה למיקום ספציפי.");
                }
            };
            Blockly.JavaScript['motion_glide_to_xy'] = function(block) {
                const secs = Blockly.JavaScript.valueToCode(block, 'SECS', Blockly.JavaScript.ORDER_ATOMIC) || '1';
                const x = Blockly.JavaScript.valueToCode(block, 'X', Blockly.JavaScript.ORDER_ATOMIC) || '0';
                const y = Blockly.JavaScript.valueToCode(block, 'Y', Blockly.JavaScript.ORDER_ATOMIC) || '0';
                return `
                    if (sprite) {
                        const startX = sprite.x;
                        const startY = sprite.y;
                        const endX = (${x});
                        const endY = (${y});
                        const durationTicks = Math.max(1, Math.round((${secs}) * 30)); // 30 FPS target

                        for (let i = 0; i <= durationTicks; i++) {
                             if (getExecutionCancelled()) break;
                             const progress = i / durationTicks;
                             sprite.x = startX + (endX - startX) * progress;
                             sprite.y = startY + (endY - startY) * progress;
                             updateSpriteAppearance(sprite.id);
                             window.updateActiveSpritePanel();
                             yield;
                        }
                        if (!getExecutionCancelled()) {
                            sprite.x = endX;
                            sprite.y = endY;
                            updateSpriteAppearance(sprite.id);
                            window.updateActiveSpritePanel();
                            log(sprite.name + ' סיימה לגלוש.');
                        }
                    }
                `;
            };

            Blockly.Blocks['motion_jump'] = {
                init: function() {
                    this.appendValueInput("HEIGHT")
                        .setCheck("Number")
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test//assets/blocklyicon/jump.svg", 34, 34, { alt: "jump icon", flipRtl: "false" }))
                        .appendField('\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0');
                    this.setInputsInline(true);
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#4C97FF");
                    this.setTooltip("גורם לדמות לקפוץ לגובה מסוים.");
                }
            };

            Blockly.JavaScript['motion_jump'] = function(block) {
                const height = Blockly.JavaScript.valueToCode(block, 'HEIGHT', Blockly.JavaScript.ORDER_ATOMIC) || '100';
                return `
                    if (sprite) {
                        const JUMP_HEIGHT = (${height});
                        const DURATION_TICKS = 15; // Approx 500ms at 30fps
                        const startY = sprite.y;
                        log(sprite.name + ' מתחילה לקפוץ...');

                        for (let i = 0; i <= DURATION_TICKS; i++) {
                            if (getExecutionCancelled()) {
                                sprite.y = startY;
                                break;
                            }
                            const progress = i / DURATION_TICKS;
                            const parabolicProgress = -4 * JUMP_HEIGHT * progress * (progress - 1);
                            sprite.y = startY + parabolicProgress;
                            
                            updateSpriteAppearance(sprite.id);
                            window.updateActiveSpritePanel();
                            yield;
                        }
                        if (!getExecutionCancelled()) {
                            sprite.y = startY;
                            updateSpriteAppearance(sprite.id);
                            window.updateActiveSpritePanel();
                            log(sprite.name + ' סיימה לקפוץ.');
                        }
                    }
                `;
            };

            Blockly.Blocks['operator_add'] = {
                init: function() {
                    this.setOutput(true, "Number");
                    this.setColour("#40BF4A");
                    this.setTooltip("החזרת סכום שני מספרים.");
                    this.appendValueInput("B").setCheck("Number");
                    this.appendDummyInput().appendField('+');
                    this.appendValueInput("A").setCheck("Number");
                    this.setInputsInline(true);
                }
            };
            Blockly.JavaScript['operator_add'] = function(block) {
                const a = Blockly.JavaScript.valueToCode(block, 'A', Blockly.JavaScript.ORDER_ADDITION) || '0';
                const b = Blockly.JavaScript.valueToCode(block, 'B', Blockly.JavaScript.ORDER_ADDITION) || '0';
                const code = `(${a} + ${b})`;
                return [code, Blockly.JavaScript.ORDER_ADDITION];
            };

            Blockly.Blocks['operator_subtract'] = {
                init: function() {
                    this.setOutput(true, "Number");
                    this.setColour("#40BF4A");
                    this.setTooltip("החזרת ההפרש בין שני מספרים.");
                    this.appendValueInput("B").setCheck("Number");
                    this.appendDummyInput().appendField('-');
                    this.appendValueInput("A").setCheck("Number");
                    this.setInputsInline(true);
                }
            };
            Blockly.JavaScript['operator_subtract'] = function(block) {
                const a = Blockly.JavaScript.valueToCode(block, 'A', Blockly.JavaScript.ORDER_SUBTRACTION) || '0';
                const b = Blockly.JavaScript.valueToCode(block, 'B', Blockly.JavaScript.ORDER_SUBTRACTION) || '0';
                const code = `(${a} - ${b})`;
                return [code, Blockly.JavaScript.ORDER_SUBTRACTION];
            };

            Blockly.Blocks['operator_multiply'] = {
                init: function() {
                    this.setOutput(true, "Number");
                    this.setColour("#40BF4A");
                    this.setTooltip("החזרת המכפלה של שני מספרים.");
                    this.appendValueInput("B").setCheck("Number");
                    this.appendDummyInput().appendField('*');
                    this.appendValueInput("A").setCheck("Number");
                    this.setInputsInline(true);
                }
            };
            Blockly.JavaScript['operator_multiply'] = function(block) {
                const a = Blockly.JavaScript.valueToCode(block, 'A', Blockly.JavaScript.ORDER_MULTIPLICATION) || '0';
                const b = Blockly.JavaScript.valueToCode(block, 'B', Blockly.JavaScript.ORDER_MULTIPLICATION) || '0';
                const code = `(${a} * ${b})`;
                return [code, Blockly.JavaScript.ORDER_MULTIPLICATION];
            };

            Blockly.Blocks['operator_divide'] = {
                init: function() {
                    this.setOutput(true, "Number");
                    this.setColour("#40BF4A");
                    this.setTooltip("החזרת תוצאת החילוק של שני מספרים.");
                    this.appendValueInput("B").setCheck("Number");
                    this.appendDummyInput().appendField('/');
                    this.appendValueInput("A").setCheck("Number");
                    this.setInputsInline(true);
                }
            };
            Blockly.JavaScript['operator_divide'] = function(block) {
                const a = Blockly.JavaScript.valueToCode(block, 'A', Blockly.JavaScript.ORDER_DIVISION) || '0';
                const b = Blockly.JavaScript.valueToCode(block, 'B', Blockly.JavaScript.ORDER_DIVISION) || '1';
                const code = `(${a} / ${b})`;
                return [code, Blockly.JavaScript.ORDER_DIVISION];
            };

            Blockly.Blocks['operator_random_number'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/random.svg", 34, 34, "*"))
                        .appendField(new FieldCustomNumber(1), "FROM")
                        .appendField(new FieldCustomNumber(10), "TO");
                    this.setInputsInline(true);
                    this.setOutput(true, "Number");
                    this.setColour("#40BF4A");
                    this.setTooltip("החזרת מספר שלם אקראי בין שני מספרים.");
                }
            };
            Blockly.JavaScript['operator_random_number'] = function(block) {
                const from = block.getFieldValue('FROM');
                const to = block.getFieldValue('TO');
                const code = `Math.floor(Math.random() * (${to} - ${from} + 1)) + ${from}`;
                return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL];
            };
            
            Blockly.Blocks['sound_play_until_done'] = {
                init: function() {
                    this.appendDummyInput()
                        .appendField(new Blockly.FieldImage("https://codejredu.github.io/test/assets/blocklyicon/play_sound.svg", 34, 34, "*"))
                        .appendField('\u00A0\u00A0')
                        .appendField(new Blockly.FieldDropdown([
                            ["מחיאות כפיים", "APPLAUSE"],
                            ["קפיצה", "BOING"],
                            ["ציוץ", "TWEET"]
                        ]), "SOUND");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour("#CF63CF");
                    this.setTooltip("מנגן צליל ומחכה לסיומו.");
                    this.setHelpUrl("");
                }
            };

            Blockly.JavaScript['sound_play_until_done'] = function(block) {
                const sound = block.getFieldValue('SOUND');
                return `
                    log('מנגן צליל: ${sound}'); 
                    const waitTime = Date.now() + 1000;
                    while (Date.now() < waitTime) {
                        if (getExecutionCancelled()) break;
                        yield;
                    }
                `;
            };

            
            // Configure Blockly's angle picker to match Scratch
            // 0 is up, clockwise
            Blockly.FieldAngle.OFFSET = 90;
            Blockly.FieldAngle.CLOCKWISE = true;
            
            workspace = Blockly.inject('blockly-area', {
                toolbox: document.getElementById('toolbox'),
                rtl: true,
                zoom: {
                    controls: true,
                    wheel: true,
                    startScale: 1.0,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                },
                renderer: 'zelos',
                theme: Blockly.Themes.Scratch
            });
            
            const toolbox = workspace.getToolbox();
            if (toolbox) {
                // Prevent the toolbox from clearing the category selection when the workspace is clicked.
                // This keeps the currently selected category visually highlighted.
                toolbox.clearSelection = () => {
                    // Do nothing, overriding the default behavior.
                };
            }

            workspace.addChangeListener((event) => {
                if (event.type === Blockly.Events.BLOCK_MOVE) {
                    const numberPad = document.getElementById('number-pad-container');
                    if (numberPad.style.display === 'block' && numberPad.currentField) {
                        const fieldBlockId = numberPad.currentField.getSourceBlock().id;
                        if (event.blockId === fieldBlockId) {
                            positionNumberPad(numberPad.currentField);
                        }
                    }
                }
            });

            const getExecutionCancelled = () => executionCancelled;

            function showBlockValue(block) {
                // Generate code for the single block
                const codeArray = Blockly.JavaScript.blockToCode(block);
                if (!codeArray || typeof codeArray[0] !== 'string') return;

                const expression = codeArray[0];
                let value;
                try {
                    // Safely evaluate the expression
                    value = new Function('return ' + expression)();
                    // Round if it's a number with many decimals
                    if (typeof value === 'number') {
                        value = Math.round(value * 1000) / 1000;
                    }
                } catch (e) {
                    console.log("Could not evaluate block value:", e);
                    value = '?'; // Show a question mark on error
                }

                // Create and position the bubble
                const bubble = document.createElement('div');
                bubble.className = 'value-bubble';
                bubble.textContent = value;
                document.body.appendChild(bubble);

                const rect = block.getSvgRoot().getBoundingClientRect();
                
                // Position bubble centered above the block
                bubble.style.left = `${rect.left + rect.width / 2}px`;
                bubble.style.top = `${rect.top}px`;

                // Fade out and remove the bubble
                setTimeout(() => {
                    bubble.style.opacity = '0';
                    setTimeout(() => {
                        if (bubble.parentElement) {
                            bubble.remove();
                        }
                    }, 400); // Wait for fade-out animation
                }, 1200); // Display for 1.2 seconds
            }

            function createGeneratorForStack(startBlock, sprite) {
                let code = '';
                let currentBlock = startBlock.getNextBlock();
                while (currentBlock) {
                    code += Blockly.JavaScript.blockToCode(currentBlock);
                    if (getExecutionCancelled()) break;
                    currentBlock = currentBlock.getNextBlock();
                }

                if (!code) return null;

                const GeneratorFunction = Object.getPrototypeOf(function*(){}).constructor;
                const func = new GeneratorFunction('sprite', 'updateSpriteAppearance', 'log', 'getExecutionCancelled', 'window', code);
                
                return func(sprite, updateSpriteAppearance, log, getExecutionCancelled, window);
            }

            function runScriptStack(startBlock) {
                saveActiveSpriteWorkspace();
                const sprite = getActiveSprite();
                if (!sprite) {
                    log("No active sprite to run script.");
                    return;
                }
                
                const generator = createGeneratorForStack(startBlock, sprite);
                if (generator) {
                    if (!scriptRunner || !scriptRunner.isRunning) {
                         scriptRunner = new ScriptRunner();
                    }
                    scriptRunner.add(generator);
                }
            }

            function executeBlock(blockId) {
                const block = workspace.getBlockById(blockId);
                if (!block || block.type.startsWith('event_')) return;
                
                log(`מפעיל בלוק בודד: ${block.type}`);
                
                const code = Blockly.JavaScript.blockToCode(block);
                const sprite = getActiveSprite();
                const GeneratorFunction = Object.getPrototypeOf(function*(){}).constructor;
                const func = new GeneratorFunction('sprite', 'updateSpriteAppearance', 'log', 'getExecutionCancelled', 'window', code);
                const generator = func(sprite, updateSpriteAppearance, log, getExecutionCancelled, window);
                
                if (!scriptRunner || !scriptRunner.isRunning) {
                    scriptRunner = new ScriptRunner();
                }
                scriptRunner.add(generator);
            }
            
            const blocklyDiv = document.getElementById('blockly-area');
            blocklyDiv.addEventListener('click', (event) => {
                if (scriptRunner && scriptRunner.isRunning) return;
                const blocklyBlockSvg = event.target.closest('.blocklyDraggable');
                if (blocklyBlockSvg) {
                    const blockId = blocklyBlockSvg.getAttribute('data-id');
                    if (blockId) {
                        const block = workspace.getBlockById(blockId);
                        if (!block) return;

                        if (block.previousConnection === null && block.getParent() === null) {
                            if (block.type === 'event_when_flag_clicked') {
                                log('לחיצה על בלוק הדגל הירוק, מפעיל את כל התסריטים.');
                                runCode();
                                return;
                            }
                            if (['event_when_sprite_clicked', 'event_when_bump', 'event_when_key_pressed'].includes(block.type)) {
                                runScriptStack(block);
                                return; 
                            }
                        }
                        
                        if (!block.outputConnection && block.getParent() === null) {
                             executeBlock(blockId);
                        } 
                        else if (block.outputConnection) {
                            showBlockValue(block);
                        }
                    }
                }
            });

            document.getElementById('run-button').addEventListener('click', runCode);
            document.getElementById('reset-button').addEventListener('click', stopAllScripts);
            
            fullscreenButton.addEventListener('click', () => {
                containerWrapper.classList.toggle('stage-expanded');
                const isExpanded = containerWrapper.classList.contains('stage-expanded');
                
                enterFullscreenIcon.classList.toggle('hidden', isExpanded);
                exitFullscreenIcon.classList.toggle('hidden', !isExpanded);
                
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize')); 
                }, 300);
            });


            function saveActiveSpriteWorkspace() {
                 if (activeSpriteId && sprites[activeSpriteId]) {
                    const dom = Blockly.Xml.workspaceToDom(workspace);
                    sprites[activeSpriteId].workspaceXml = Blockly.Xml.domToText(dom);
                }
            }
            
            function runCode() {
                if (scriptRunner && scriptRunner.isRunning) {
                    log('תסריט כבר רץ. לחץ על עצור לפני הפעלה מחדש.');
                    return;
                }
                saveActiveSpriteWorkspace();
                scriptRunner = new ScriptRunner();
                
                log('התסריט הופעל.');

                Object.values(sprites).forEach(sprite => {
                    if (sprite.isGif && sprite.animation) {
                        sprite.animation.isPlaying = true;
                        sprite.animation.previewIsPlaying = false;
                        sprite.animation.currentFrame = 0;
                        updatePropertiesPanel(); // Update play/pause button state
                    }
                });

                let scriptsFound = false;
                Object.values(sprites).forEach(sprite => {
                    if (sprite.workspaceXml) {
                        const tempWorkspace = new Blockly.Workspace();
                        Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(sprite.workspaceXml), tempWorkspace);
                        const topBlocks = tempWorkspace.getTopBlocks(true);
                        const flagClickScripts = topBlocks.filter(block => block.type === 'event_when_flag_clicked');
                        
                        flagClickScripts.forEach(startBlock => {
                           const generator = createGeneratorForStack(startBlock, sprite);
                           if (generator) {
                               scriptRunner.add(generator);
                               scriptsFound = true;
                           }
                        });
                        tempWorkspace.dispose();
                    }
                });

                if(!scriptsFound) {
                     log('לא נמצאו תסריטים שמתחילים בדגל ירוק.');
                     scriptRunner.stop(); // Stop immediately if no scripts to run
                }
            }
            
            window.addEventListener('kidi-broadcast', (e) => {
                const message = e.detail.message;
                log(`התקבל מסר: ${message}`);
                runBroadcastScripts(message);
            });

            function runBroadcastScripts(message) {
                saveActiveSpriteWorkspace();
                if (!scriptRunner || !scriptRunner.isRunning) {
                    scriptRunner = new ScriptRunner();
                }

                Object.values(sprites).forEach(sprite => {
                    if (!sprite.workspaceXml) return;
                    
                    const tempWorkspace = new Blockly.Workspace();
                    try {
                        Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(sprite.workspaceXml), tempWorkspace);
                        const topBlocks = tempWorkspace.getTopBlocks(true);
                        
                        const matchingHatBlocks = topBlocks.filter(block => 
                            block.type === 'event_when_broadcast_received' && 
                            block.getFieldValue('MESSAGE') === message
                        );
                        
                        matchingHatBlocks.forEach(startBlock => {
                            const generator = createGeneratorForStack(startBlock, sprite);
                            if(generator) scriptRunner.add(generator);
                        });
                        
                    } catch (err) {
                        console.error("Error processing workspace for broadcast:", err);
                    } finally {
                        tempWorkspace.dispose();
                    }
                });
            }


            function handleSpriteClick(spriteId) {
                saveActiveSpriteWorkspace();
                const sprite = sprites[spriteId];
                if (!sprite || !sprite.workspaceXml) return;

                if (!scriptRunner || !scriptRunner.isRunning) {
                    scriptRunner = new ScriptRunner();
                }
                
                const tempWorkspace = new Blockly.Workspace();
                Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(sprite.workspaceXml), tempWorkspace);
                const topBlocks = tempWorkspace.getTopBlocks(true);
                const clickScripts = topBlocks.filter(block => block.type === 'event_when_sprite_clicked');

                clickScripts.forEach(startBlock => {
                    const generator = createGeneratorForStack(startBlock, sprite);
                    if (generator) scriptRunner.add(generator);
                });
                tempWorkspace.dispose();
            }
            
             // --- Collision Detection and Handling ---
            function checkCollisions() {
                if (isLoadingProject) return;

                const spriteIds = Object.keys(sprites);
                if (spriteIds.length < 2) return;

                for (let i = 0; i < spriteIds.length; i++) {
                    for (let j = i + 1; j < spriteIds.length; j++) {
                        const id1 = spriteIds[i];
                        const id2 = spriteIds[j];
                        
                        const el1 = document.getElementById(id1);
                        const el2 = document.getElementById(id2);
                        
                        if (!el1 || !el2 || sprites[id1].opacity === 0 || sprites[id2].opacity === 0) continue;
                        
                        const rect1 = el1.getBoundingClientRect();
                        const rect2 = el2.getBoundingClientRect();

                        const isColliding = !(rect1.right < rect2.left || 
                                              rect1.left > rect2.right || 
                                              rect1.bottom < rect2.top || 
                                              rect1.top > rect2.bottom);
                        
                        const collisionKey = [id1, id2].sort().join('-');

                        if (isColliding) {
                            if (!collisionState.has(collisionKey)) {
                                collisionState.add(collisionKey);
                                log(`התנגשות בין ${sprites[id1].name} ל-${sprites[id2].name}`);
                                triggerBumpScripts(id1, id2);
                            }
                        } else {
                            if (collisionState.has(collisionKey)) {
                                collisionState.delete(collisionKey);
                                log(`${sprites[id1].name} ו-${sprites[id2].name} נפרדו.`);
                            }
                        }
                    }
                }
            }

            function triggerBumpScripts(id1, id2) {
                saveActiveSpriteWorkspace();
                if (!scriptRunner || !scriptRunner.isRunning) {
                    scriptRunner = new ScriptRunner();
                }

                const runForSprite = (sprite) => {
                    if (!sprite.workspaceXml) return;
                    const tempWorkspace = new Blockly.Workspace();
                    try {
                        Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(sprite.workspaceXml), tempWorkspace);
                        const bumpScript = tempWorkspace.getTopBlocks(true).find(block => block.type === 'event_when_bump');
                        if (bumpScript) {
                            const generator = createGeneratorForStack(bumpScript, sprite);
                            if(generator) scriptRunner.add(generator);
                        }
                    } catch (e) {
                        console.error("Error processing bump script workspace", e);
                    } finally {
                        tempWorkspace.dispose();
                    }
                };

                runForSprite(sprites[id1]);
                runForSprite(sprites[id2]);
            }


            function handleKeyPress(event) {
                const keyMap = { 'SPACE': ' ', 'UP': 'ArrowUp', 'DOWN': 'ArrowDown', 'RIGHT': 'ArrowRight', 'LEFT': 'ArrowLeft' };
                const pressedKey = event.key;
                
                saveActiveSpriteWorkspace();
                if (!scriptRunner || !scriptRunner.isRunning) {
                    scriptRunner = new ScriptRunner();
                }

                Object.values(sprites).forEach(sprite => {
                    if (sprite.workspaceXml) {
                        const tempWorkspace = new Blockly.Workspace();
                        try {
                            Blockly.Xml.domToWorkspace(Blockly.Xml.textToDom(sprite.workspaceXml), tempWorkspace);
                            const topBlocks = tempWorkspace.getTopBlocks(true);
                            
                            topBlocks.filter(block => block.type === 'event_when_key_pressed' && keyMap[block.getFieldValue('KEY')] === pressedKey)
                                .forEach(startBlock => {
                                    const generator = createGeneratorForStack(startBlock, sprite);
                                    if (generator) scriptRunner.add(generator);
                                });
                        } catch(e) {
                            console.error("Error in handleKeyPress workspace processing:", e);
                        } finally {
                            tempWorkspace.dispose();
                        }
                    }
                });
            }
            document.addEventListener('keydown', handleKeyPress);

            function stopAllScripts() {
                log('לחצн עצור נלחץ.');
                if (scriptRunner) {
                    scriptRunner.stop();
                }
                
                Object.values(sprites).forEach(sprite => {
                    const bubble = document.querySelector(`#container-${sprite.id} .speech-bubble`);
                    if (bubble) bubble.classList.remove('visible');

                    if (sprite.isGif && sprite.animation) {
                        sprite.animation.isPlaying = false;
                        sprite.animation.previewIsPlaying = false;
                        sprite.animation.currentFrame = 0;
                        drawGifFrame(sprite);
                    }
                });

                updatePropertiesPanel(); // To update play/pause button state
                log('כל התסריטים נעצרו.');
            }

            function deleteBackdrop(cardElement) {
                const urlToDelete = cardElement.dataset.url;
                const currentBackdropUrl = stageArea.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/, '$2');

                const allBackdrops = document.querySelectorAll('#backdrops-list .backdrop-card');
                if (allBackdrops.length <= 1) {
                    alert("לא ניתן למחוק את הרקע האחרון.");
                    return;
                }

                cardElement.remove();

                if (urlToDelete === currentBackdropUrl) {
                    const firstRemainingBackdrop = document.querySelector('#backdrops-list .backdrop-card');
                    if (firstRemainingBackdrop) {
                        window.switchBackdrop(firstRemainingBackdrop.dataset.url);
                    } else {
                        stageArea.style.backgroundImage = 'none';
                    }
                }
                 Blockly.getMainWorkspace().refreshToolboxSelection();
            }
            
            function createBackdropCard(url) {
                const card = document.createElement('div');
                card.classList.add('backdrop-card');
                card.style.backgroundImage = `url("${url}")`;
                card.dataset.url = url;

                const deleteBtn = document.createElement('div');
                deleteBtn.classList.add('delete-button');
                deleteBtn.textContent = 'X';
                card.appendChild(deleteBtn);

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteBackdrop(card);
                });

                backdropsList.appendChild(card);
                return card;
            }
            
            function createDefaultBackdrop() {
                const url = "https://codejredu.github.io/test/assets/bg/farm.svg";
                const card = createBackdropCard(url);
                card.classList.add('selected');
                stageArea.style.backgroundImage = `url("${url}")`;
            }

            function createDefaultSprite() {
                const defaultSprite = createNewSprite('חתול', 'https://codejredu.github.io/claudejr/GingerCat.svg', 0, 0);
            }

            function handleBackdropSelection(e) {
                const card = e.target.closest('.backdrop-card');
                if (card && e.target !== card.querySelector('.delete-button')) {
                    const url = card.dataset.url;
                    if (url) {
                       window.switchBackdrop(url);
                    }
                }
            }

            function handleGallerySelection(e) {
                const url = e.target.src;
                if (url) {
                    const newCard = createBackdropCard(url);
                    window.switchBackdrop(url);
                    backgroundGallery.classList.remove('visible');
                }
            }

            function handleSpriteGallerySelection(e) {
                const target = e.target;
                if (target.tagName === 'IMG' && target.classList.contains('thumbnail')) {
                    const url = target.src;
                    const name = target.alt || 'דמות חדשה';
                    createNewSprite(name, url, 0, 0);
                    spriteGallery.classList.remove('visible');
                }
            }
            
            // Number Pad Logic
            const numberPad = document.getElementById('number-pad-container');
            const numberPadDisplay = document.getElementById('number-pad-display');
            const numberPadGrid = numberPad.querySelector('.number-pad-grid');
            const numberPadDone = document.getElementById('number-pad-done');
            
            numberPadGrid.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    const value = e.target.dataset.value;
                    if (value === 'backspace') {
                        numberPadDisplay.textContent = numberPadDisplay.textContent.slice(0, -1);
                    } else {
                        // Prevent multiple decimals
                        if (value === '.' && numberPadDisplay.textContent.includes('.')) return;
                        numberPadDisplay.textContent += value;
                    }
                }
            });

            numberPadDone.addEventListener('click', () => {
                const field = numberPad.currentField;
                if (field) {
                    let newValue = parseFloat(numberPadDisplay.textContent);
                    if (isNaN(newValue)) {
                        newValue = 0;
                    }
                    field.setValue(newValue);
                }
                numberPad.style.display = 'none';
                numberPad.currentField = null;
            });
            
            // Hide number pad when clicking outside
            document.addEventListener('click', (e) => {
                // If the click is not on the number pad and not on a blockly field
                if (numberPad.style.display === 'block' && !numberPad.contains(e.target) && !e.target.closest('.blocklyText')) {
                    numberPadDone.click();
                }
            }, true);
            
            // --- Save/Load Project Logic ---
            const saveProject = () => {
                if (activeSpriteId && sprites[activeSpriteId]) {
                    const dom = Blockly.Xml.workspaceToDom(workspace);
                    sprites[activeSpriteId].workspaceXml = Blockly.Xml.domToText(dom);
                }
                const backdrops = Array.from(document.querySelectorAll('#backdrops-list .backdrop-card')).map(card => card.dataset.url);
                const currentBackdrop = stageArea.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/, '$2');
                
                // Create a serializable version of sprites
                const serializableSprites = {};
                for (const id in sprites) {
                    const { animation, ...rest } = sprites[id]; // Exclude non-serializable animation object
                    serializableSprites[id] = rest;
                }

                const projectData = {
                    sprites: serializableSprites,
                    backdrops: backdrops,
                    currentBackdrop: currentBackdrop
                };

                const dataStr = JSON.stringify(projectData, null, 2);
                const dataBlob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(dataBlob);

                const a = document.createElement('a');
                a.href = url;
                a.download = 'kidi-project.kidi';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                log('הפרויקט נשמר.');
            };

            const loadSpriteFromData = (spriteData) => {
                const { id, name, imageUrl, x, y, direction, opacity, size, rotationStyle, isCustom, characterData, isGif, gifSpeed } = spriteData;

                spriteData.size = size || 100;
                spriteData.rotationStyle = rotationStyle || 'all-around'; // Add for compatibility
                spriteData.isGif = isGif || false;
                spriteData.gifSpeed = gifSpeed || 1.0;
                spriteData.animation = null; // Will be loaded async
                sprites[id] = spriteData;

                const spriteCard = document.createElement('div');
                spriteCard.classList.add('sprite-card');
                spriteCard.dataset.spriteId = id;
                spriteCard.innerHTML = `
                    <img src="${imageUrl}" alt="${name}">
                    <div class="delete-button">X</div>
                     ${isCustom ? `
                        <div class="edit-button" title="ערוך דמות">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M17.414 2.586a2 2 0 00-2.828 0L7 10.172V13h2.828l7.586-7.586a2 2 0 000-2.828z" />
                                <path fill-rule="evenodd" d="M2 6a2 2 0 012-2h4a1 1 0 010 2H4v10h10v-4a1 1 0 112 0v4a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" clip-rule="evenodd" />
                            </svg>
                        </div>` : ''}
                `;
                spritesList.appendChild(spriteCard);

                const spriteContainer = document.createElement('div');
                spriteContainer.id = `container-${id}`;
                spriteContainer.classList.add('sprite-container');
                const mainSprite = document.createElement('div');
                mainSprite.classList.add('sprite-wrapper');
                mainSprite.id = id;
                mainSprite.innerHTML = `
                    <img src="${imageUrl}" alt="${name}">
                    <canvas class="hidden absolute top-0 left-0 w-full h-full"></canvas>
                    <div class="speech-bubble"></div>
                `;
                
                spriteContainer.appendChild(mainSprite);
                stageArea.appendChild(spriteContainer);

                if (spriteData.isGif) {
                    loadGifData(spriteData);
                }
                
                const wrapper = spriteContainer.querySelector('.sprite-wrapper');
                wrapper.addEventListener('click', (e) => { e.stopPropagation(); if (justDragged) return; handleSpriteClick(id); });
                wrapper.addEventListener('mousedown', (e) => startDrag(e, id));
                wrapper.addEventListener('touchstart', (e) => startDrag(e, id));
                
                spriteCard.addEventListener('click', () => setActiveSprite(id));
                spriteCard.querySelector('.delete-button').addEventListener('click', (e) => { e.stopPropagation(); deleteSprite(id); });
                if (isCustom) {
                    spriteCard.querySelector('.edit-button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        openCreatorForEdit(id);
                    });
                }


                updateSpriteAppearance(id);
            };

            const loadProject = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                isLoadingProject = true; // Set flag before loading

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const projectData = JSON.parse(event.target.result);

                        if (!projectData.sprites || !projectData.backdrops) {
                            throw new Error("קובץ פרויקט לא תקין.");
                        }
                        
                        stopAllScripts();
                        Object.keys(sprites).forEach(id => {
                            document.getElementById(`container-${id}`)?.remove();
                            document.querySelector(`.sprite-card[data-sprite-id="${id}"]`)?.remove();
                        });

                        sprites = {};
                        activeSpriteId = null;
                        workspace.clear();
                        backdropsList.innerHTML = '';
                        
                        projectData.backdrops.forEach(createBackdropCard);

                        window.switchBackdrop(projectData.currentBackdrop);

                        Object.values(projectData.sprites).forEach(loadSpriteFromData);
                        
                        const firstSpriteId = Object.keys(projectData.sprites)[0];
                        if (firstSpriteId) {
                            setActiveSprite(firstSpriteId);
                        }
                        
                        log('הפרויקט נטען בהצלחה.');

                    } catch (error) {
                        console.error("שגיאה בטעינת הפרויקטים:", error);
                    } finally {
                        e.target.value = null;
                        setTimeout(() => { isLoadingProject = false; }, 100); // Unset flag after a short delay
                    }
                };
                 reader.onerror = () => {
                    console.error("שגיאה בקריאת הקובץ.");
                    isLoadingProject = false; // Unset flag on error
                };
                reader.readAsText(file);
            };

            saveButton.addEventListener('click', saveProject);
            loadButton.addEventListener('click', () => loadInput.click());
            loadInput.addEventListener('change', loadProject);


            // --- Properties Panel Listeners ---
            function setupPropertiesPanelListeners() {
                propName.addEventListener('change', (e) => {
                    const sprite = getActiveSprite();
                    if (sprite) sprite.name = e.target.value;
                });
                propX.addEventListener('change', (e) => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.x = Number(e.target.value);
                        updateSpriteAppearance(sprite.id);
                    }
                });
                propY.addEventListener('change', (e) => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.y = Number(e.target.value);
                        updateSpriteAppearance(sprite.id);
                    }
                });
                propSize.addEventListener('change', (e) => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.size = Number(e.target.value);
                        updateSpriteAppearance(sprite.id);
                    }
                });
                
                propDirection.addEventListener('change', (e) => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.direction = Number(e.target.value);
                        updateSpriteAppearance(sprite.id);
                    }
                });
                
                propDirection.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const sprite = getActiveSprite();
                    if (!sprite) return;
                    
                    anglePickerWidget.style.display = 'flex';
                    const inputRect = propDirection.getBoundingClientRect();
                    const widgetWidth = anglePickerWidget.offsetWidth;
                    const widgetHeight = anglePickerWidget.offsetHeight;

                    let left = inputRect.left - widgetWidth - 10;
                    let top = inputRect.top + (inputRect.height / 2) - (widgetHeight / 2);

                    if (left < 5) { 
                        left = inputRect.left + (inputRect.width / 2) - (widgetWidth / 2);
                        top = inputRect.bottom + 5;
                    }
                     if (top < 5) top = 5;
                    if (top + widgetHeight > window.innerHeight) top = window.innerHeight - widgetHeight - 5;

                    anglePickerWidget.style.top = `${top}px`;
                    anglePickerWidget.style.left = `${left}px`;
                    anglePickerHandle.style.transform = `rotate(${sprite.direction - 90}deg)`;
                });

                propShow.addEventListener('click', () => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.opacity = 1;
                        updateSpriteAppearance(sprite.id);
                        updatePropertiesPanel();
                    }
                });
                propHide.addEventListener('click', () => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.opacity = 0;
                        updateSpriteAppearance(sprite.id);
                        updatePropertiesPanel();
                    }
                });
                
                // Rotation Style Listeners
                propRotationAllAround.addEventListener('click', () => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.rotationStyle = 'all-around';
                        updateSpriteAppearance(sprite.id);
                        updatePropertiesPanel();
                    }
                });
                propRotationLeftRight.addEventListener('click', () => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.rotationStyle = 'left-right';
                        updateSpriteAppearance(sprite.id);
                        updatePropertiesPanel();
                    }
                });
                propRotationDontRotate.addEventListener('click', () => {
                    const sprite = getActiveSprite();
                    if (sprite) {
                        sprite.rotationStyle = 'dont-rotate';
                        updateSpriteAppearance(sprite.id);
                        updatePropertiesPanel();
                    }
                });

                // GIF Animation Panel Listeners
                gifSpeedSlider.addEventListener('input', (e) => {
                    const sprite = getActiveSprite();
                    if (sprite && sprite.isGif) {
                        sprite.gifSpeed = Number(e.target.value);
                        gifSpeedValue.textContent = `${sprite.gifSpeed.toFixed(1)}x`;
                    }
                });
                gifPlayPauseBtn.addEventListener('click', () => {
                    const sprite = getActiveSprite();
                    if (sprite && sprite.isGif && sprite.animation) {
                        sprite.animation.previewIsPlaying = !sprite.animation.previewIsPlaying;
                        if(sprite.animation.previewIsPlaying) {
                            sprite.animation.timeSinceLastFrame = 0; // Reset timer on play
                        }
                        updatePropertiesPanel(); // Update icon
                    }
                });
            }
            
            // --- Custom Angle Picker Logic ---
            let isDraggingAngle = false;

            const updateAngleFromEvent = (e) => {
                 const sprite = getActiveSprite();
                 if (!sprite) return;

                const dialRect = anglePickerDial.getBoundingClientRect();
                const centerX = dialRect.left + dialRect.width / 2;
                const centerY = dialRect.top + dialRect.height / 2;
                const pointer = e.touches ? e.touches[0] : e;
                const deltaX = pointer.clientX - centerX;
                const deltaY = pointer.clientY - centerY;
                
                let degrees = Math.atan2(deltaX, -deltaY) * (180 / Math.PI);
                if (degrees < 0) degrees += 360;
                degrees = Math.round(degrees);
                if (degrees === 360) degrees = 0;

                sprite.direction = degrees;
                propDirection.value = degrees;
                anglePickerHandle.style.transform = `rotate(${degrees - 90}deg)`;
                updateSpriteAppearance(sprite.id);
            };

            anglePickerDial.addEventListener('mousedown', (e) => {
                e.preventDefault();
                isDraggingAngle = true;
                updateAngleFromEvent(e);
            });
            anglePickerDial.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDraggingAngle = true;
                updateAngleFromEvent(e);
            });

            document.addEventListener('mousemove', (e) => { if (isDraggingAngle) updateAngleFromEvent(e); });
            document.addEventListener('touchmove', (e) => { if (isDraggingAngle) updateAngleFromEvent(e); });
            document.addEventListener('mouseup', () => { isDraggingAngle = false; });
            document.addEventListener('touchend', () => { isDraggingAngle = false; });
            document.addEventListener('click', (e) => {
                if (!anglePickerWidget.contains(e.target) && e.target !== propDirection) {
                    anglePickerWidget.style.display = 'none';
                }
            });

            // --- GIF Animation Logic ---
            async function loadGifData(sprite) {
                try {
                    const response = await fetch(sprite.imageUrl);
                    const arrayBuffer = await response.arrayBuffer();
                    const gifData = parseGIF(arrayBuffer);

                    sprite.animation = {
                        width: gifData.width,
                        height: gifData.height,
                        frames: gifData.frames,
                        loopCount: gifData.loopCount,
                        isPlaying: false,
                        previewIsPlaying: false,
                        currentFrame: 0,
                        timeSinceLastFrame: 0,
                        patchCanvas: document.createElement('canvas'),
                    };
                    sprite.animation.patchCanvas.width = gifData.width;
                    sprite.animation.patchCanvas.height = gifData.height;

                    const wrapper = document.getElementById(sprite.id);
                    if (wrapper) {
                        const img = wrapper.querySelector('img');
                        const canvas = wrapper.querySelector('canvas');
                        img.classList.add('hidden');
                        canvas.classList.remove('hidden');
                        canvas.width = gifData.width;
                        canvas.height = gifData.height;
                    }
                    
                    drawGifFrame(sprite);
                    updatePropertiesPanel();

                } catch (e) {
                    console.error(`Failed to load or parse GIF for sprite ${sprite.name}:`, e);
                    sprite.isGif = false;
                }
            }
            
            function drawGifFrame(sprite) {
                if (!sprite.isGif || !sprite.animation) return;
                
                const frame = sprite.animation.frames[sprite.animation.currentFrame];
                if (!frame) return;
                
                const { width, height, patchCanvas } = sprite.animation;
                const patchCtx = patchCanvas.getContext('2d');
                
                if (sprite.animation.currentFrame === 0 || frame.disposalMethod === 2) {
                     patchCtx.clearRect(0, 0, width, height);
                }

                const imageData = patchCtx.createImageData(frame.w, frame.h);
                const transparentIndex = frame.transparentColorIndex;

                frame.pixelIndices.forEach((pixel, i) => {
                    if (pixel !== transparentIndex) {
                        const color = frame.colorTable[pixel];
                        if (color) {
                            imageData.data[i * 4 + 0] = color[0];
                            imageData.data[i * 4 + 1] = color[1];
                            imageData.data[i * 4 + 2] = color[2];
                            imageData.data[i * 4 + 3] = 255; // Opaque
                        }
                    }
                    // Pixels with the transparent index will be left as rgba(0,0,0,0) by default
                });
                
                patchCtx.putImageData(imageData, frame.left, frame.top);
                
                const wrapper = document.getElementById(sprite.id);
                if (wrapper) {
                    const canvas = wrapper.querySelector('canvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(patchCanvas, 0, 0);
                    }
                }
            }

            function updateGifAnimations(deltaTime) {
                Object.values(sprites).forEach(sprite => {
                    if (sprite.isGif && sprite.animation && sprite.animation.frames.length > 0 && (sprite.animation.isPlaying || sprite.animation.previewIsPlaying)) {
                        sprite.animation.timeSinceLastFrame += deltaTime;
                        const currentFrameData = sprite.animation.frames[sprite.animation.currentFrame];
                        const requiredDelay = (currentFrameData.delay * 10) / sprite.gifSpeed;

                        if (sprite.animation.timeSinceLastFrame >= requiredDelay) {
                            sprite.animation.currentFrame = (sprite.animation.currentFrame + 1) % sprite.animation.frames.length;
                            sprite.animation.timeSinceLastFrame = 0;
                            drawGifFrame(sprite);
                        }
                    }
                });
            }

            
            // --- Character Creator Logic ---
            const ASSET_CATEGORIES = {
                shirt: {
                    label: 'חולצות',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/shirt1.svg',
                        'https://codejredu.github.io/test/assets/parts/shirt2.svg',
                        'https://codejredu.github.io/test/assets/parts/shirt3.svg',
                        'https://codejredu.github.io/test/assets/parts/shirt4.svg',
                        'https://codejredu.github.io/test/assets/parts/shirt5.svg',
                        ...Array(2).fill(0).map((_, i) => `data:image/svg+xml;base64,${safeBtoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><path d="M 30 30 L 70 30 L 65 70 L 35 70 Z" fill="${['#14b8a6', '#06b6d4'][i]}"/></svg>`)}`)
                    ]
                },
                 pants: {
                    label: 'מכנסיים',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/pants1.svg',
                        'https://codejredu.github.io/test/assets/parts/pants2.svg',
                        'https://codejredu.github.io/test/assets/parts/pants3.svg',
                        'https://codejredu.github.io/test/assets/parts/pants4.svg',
                        'https://codejredu.github.io/test/assets/parts/pants5.svg',
                        'https://codejredu.github.io/test/assets/parts/pants6.svg',
                        'https://codejredu.github.io/test/assets/parts/pants7.svg',
                        'https://codejredu.github.io/test/assets/parts/pants8.svg'
                    ]
                },
                dresses: {
                    label: 'שמלות',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/drees1.svg',
                        'https://codejredu.github.io/test/assets/parts/drees2.svg',
                        'https://codejredu.github.io/test/assets/parts/drees3.svg',
                        'https://codejredu.github.io/test/assets/parts/drees4.svg',
                        'https://codejredu.github.io/test/assets/parts/drees5.svg'
                    ]
                },
                shoes: {
                    label: 'נעליים',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/shoes1.svg',
                        'https://codejredu.github.io/test/assets/parts/shoes2.svg',
                        'https://codejredu.github.io/test/assets/parts/shoes3.svg',
                        'https://codejredu.github.io/test/assets/parts/shoes4.svg',
                        'https://codejredu.github.io/test/assets/parts/shoes5.svg',
                        ...Array(2).fill(0).map((_, i) => `data:image/svg+xml;base64,${safeBtoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><ellipse cx="35" cy="50" rx="15" ry="6" fill="${['#db2777', '#e11d48'][i]}"/><ellipse cx="65" cy="50" rx="15" ry="6" fill="${['#db2777', '#e11d48'][i]}"/></svg>`)}`)
                    ]
                },
                head: {
                    label: 'ראש',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/face1.svg',
                        'https://codejredu.github.io/test/assets/parts/face2.svg',
                        'https://codejredu.github.io/test/assets/parts/face3.svg',
                        'https://codejredu.github.io/test/assets/parts/face4.svg',
                        'https://codejredu.github.io/test/assets/parts/face5.svg',
                        'https://codejredu.github.io/test/assets/parts/face6.svg',
                        'https://codejredu.github.io/test/assets/parts/face7.svg',
                        'https://codejredu.github.io/test/assets/parts/face8.svg',
                        'https://codejredu.github.io/test/assets/parts/face9.svg',
                        'https://codejredu.github.io/test/assets/parts/face10.svg',
                        'https://codejredu.github.io/test/assets/parts/face11.svg',
                        'https://codejredu.github.io/test/assets/parts/face12.svg',
                        'https://codejredu.github.io/test/assets/parts/face13.svg',
                        'https://codejredu.github.io/test/assets/parts/face14.svg',
                        'https://codejredu.github.io/test/assets/parts/face15.svg',
                        'https://codejredu.github.io/test/assets/parts/face16.svg',
                        'https://codejredu.github.io/test/assets/parts/face17.svg',
                        'https://codejredu.github.io/test/assets/parts/face18.svg',
                        'https://codejredu.github.io/test/assets/parts/face19.svg',
                        'https://codejredu.github.io/test/assets/parts/face20.svg',
                        ...['#e0ac69', '#ffdbac', '#8d5524'].map(color => `data:image/svg+xml;base64,${safeBtoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45" fill="${color}"/></svg>`)}`)
                    ]
                },
                eyes: { 
                    label: 'עיניים', 
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/eye1.svg',
                        'https://codejredu.github.io/test/assets/parts/eye2.svg',
                        'https://codejredu.github.io/test/assets/parts/eye3.svg',
                        'https://codejredu.github.io/test/assets/parts/eye4.svg',
                        'https://codejredu.github.io/test/assets/parts/eye5.svg',
                        ...Array(2).fill(0).map((_, i) => `data:image/svg+xml;base64,${safeBtoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><g><circle cx="35" cy="50" r="${4 + i*0.5}" fill="white" stroke="black" stroke-width="1"/><circle cx="35" cy="50" r="${2 + i*0.2}" fill="black"/><circle cx="65" cy="50" r="${4 + i*0.5}" fill="white" stroke="black" stroke-width="1"/><circle cx="65" cy="50" r="${2 + i*0.2}" fill="black"/></g></svg>`)}`)
                    ] 
                },
                nose: {
                    label: 'אפים',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/Nose1.svg',
                        'https://codejredu.github.io/test/assets/parts/Nose2.svg',
                        'https://codejredu.github.io/test/assets/parts/Nose3.svg',
                        'https://codejredu.github.io/test/assets/parts/Nose4.svg',
                        'https://codejredu.github.io/test/assets/parts/Nose5.svg',
                        'https://codejredu.github.io/test/assets/parts/Nose6.svg',
                        'https://codejredu.github.io/test/assets/parts/Nose7.svg'
                    ]
                },
                mouth: {
                    label: 'פה',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/mouth1.svg',
                        'https://codejredu.github.io/test/assets/parts/mouth2.svg',
                        'https://codejredu.github.io/test/assets/parts/mouth3.svg',
                        'https://codejredu.github.io/test/assets/parts/mouth4.svg',
                        'https://codejredu.github.io/test/assets/parts/mouth5.svg',
                        'https://codejredu.github.io/test/assets/parts/mouth6.svg',
                        'https://codejredu.github.io/test/assets/parts/mouth7.svg'
                    ]
                },
                hand: {
                    label: 'ידים',
                    parts: [
                        'https://codejredu.github.io/test/assets/parts/hand1.svg',
                        'https://codejredu.github.io/test/assets/parts/hand2.svg',
                        'https://codejredu.github.io/test/assets/parts/hand3.svg',
                        'https://codejredu.github.io/test/assets/parts/hand4.svg',
                        'https://codejredu.github.io/test/assets/parts/hand5.svg',
                        ...['#e0ac69', '#ffdbac', '#8d5524'].map(color => `data:image/svg+xml;base64,${safeBtoa(`<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="25" fill="${color}"/></svg>`)}`)
                    ]
                }
            };

            const PART_PROPORTIONS = {
                head:    { scale: { w: 0.28, h: 0.28 }, offset: { x: 0.5, y: 0.22 } },
                shirt:   { scale: { w: 0.35, h: 0.3 }, offset: { x: 0.5, y: 0.45 } },
                pants:   { scale: { w: 0.32, h: 0.4 }, offset: { x: 0.5, y: 0.75 } },
                dresses: { scale: { w: 0.38, h: 0.55 }, offset: { x: 0.5, y: 0.65 } },
                shoes:   { scale: { w: 0.35, h: 0.1 }, offset: { x: 0.5, y: 0.96 } },
                eyes:    { scale: { w: 0.15, h: 0.08 }, offset: { x: 0.5, y: 0.20 } },
                nose:    { scale: { w: 0.08, h: 0.08 }, offset: { x: 0.5, y: 0.24 } },
                mouth:   { scale: { w: 0.1, h: 0.05 }, offset: { x: 0.5, y: 0.28 } },
                hand:    { scale: { w: 0.15, h: 0.18 }, offset: { x: 0.35, y: 0.55 } }
            };
            const COLOR_PALETTE = ['#000000', '#FFFFFF', '#FF5733', '#FFC300', '#4CAF50', '#3498DB', '#9B59B6', '#E91E63', '#9E9E9E', '#795548', '#607D8B', '#ffdfba', '#ffadad', '#ffd6a5', '#caffbf', '#a0c4ff'];
            const SKIN_TONE_PALETTE = ['#8d5524', '#c68642', '#e0ac69', '#f1c27d', '#ffdbac', '#ead2c2'];

            const DRAW_ORDER = ['pants', 'shoes', 'shirt', 'hands', 'dresses', 'head', 'nose', 'mouth', 'eyes'];
            
            async function getAssetAsText(src) {
                if (assetCache[src]) return assetCache[src];
                try {
                    if (src.startsWith('data:image/svg+xml;base64,')) {
                        const svgText = safeAtob(src.split(',')[1]);
                        assetCache[src] = svgText;
                        return svgText;
                    }
                    const response = await fetch(src);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const svgText = await response.text();
                    assetCache[src] = svgText;
                    return svgText;
                } catch (error) {
                    console.error(`Failed to fetch asset: ${src}`, error);
                    return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text x="50" y="50" text-anchor="middle">Error</text></svg>`;
                }
            }
            
            function colorizeSvg(svgText, newColor) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgText, "image/svg+xml");
                    const svg = doc.documentElement;
                    
                    const imageElement = doc.querySelector('image');
                    const vectorElements = doc.querySelector('path, circle, rect, polygon, ellipse, line');

                    if (imageElement && !vectorElements) {
                        const r = parseInt(newColor.slice(1, 3), 16) / 255;
                        const g = parseInt(newColor.slice(3, 5), 16) / 255;
                        const b = parseInt(newColor.slice(5, 7), 16) / 255;
                        const lr = 0.2126, lg = 0.7152, lb = 0.0722;
                        const matrix = [
                            lr * r, lg * r, lb * r, 0, 0,
                            lr * g, lg * g, lb * g, 0, 0,
                            lr * b, lg * b, lb * b, 0, 0,
                            0,      0,      0,      1, 0
                        ].join(' ');
                        
                        let defs = svg.querySelector('defs');
                        if (!defs) {
                            defs = doc.createElementNS("http://www.w3.org/2000/svg", 'defs');
                            svg.insertBefore(defs, svg.firstChild);
                        }

                        const filterId = `colorize-filter-${Date.now()}`;
                        const filter = doc.createElementNS("http://www.w3.org/2000/svg", 'filter');
                        filter.setAttribute('id', filterId);

                        const colorMatrix = doc.createElementNS("http://www.w3.org/2000/svg", 'feColorMatrix');
                        colorMatrix.setAttribute('type', 'matrix');
                        colorMatrix.setAttribute('values', matrix);
                        
                        filter.appendChild(colorMatrix);
                        defs.appendChild(filter);
                        imageElement.setAttribute('filter', `url(#${filterId})`);
                    } else {
                         const isProtectedColor = (c) => !c || ['none', '#fff', '#ffffff', 'white', '#000', '#000000', 'black'].includes(c.toLowerCase()) || c.includes('rgba(0,0,0,0)');
                        
                        doc.querySelectorAll('style').forEach(style => {
                            style.textContent = style.textContent.replace(/#([0-9a-f]{3}){1,2}|rgb\([^)]+\)/ig, (match) => isProtectedColor(match) ? match : newColor);
                        });
                        
                        doc.querySelectorAll('*').forEach(el => {
                            ['fill', 'stroke'].forEach(attr => {
                                const originalColor = el.getAttribute(attr);
                                if (originalColor && !isProtectedColor(originalColor)) el.setAttribute(attr, newColor);
                            });
                            if (el.style.fill && !isProtectedColor(el.style.fill)) el.style.fill = newColor;
                            if (el.style.stroke && !isProtectedColor(el.style.stroke)) el.style.stroke = newColor;
                        });
                    }
                    return new XMLSerializer().serializeToString(svg);
                } catch (e) {
                    console.error("Failed to colorize SVG:", e);
                    return svgText;
                }
            }


            function loadImage(src) {
                if (imageCache[src]) return Promise.resolve(imageCache[src]);
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        imageCache[src] = img;
                        resolve(img);
                    };
                    img.onerror = (err) => {
                         console.error(`Failed to load image from src: ${src.substring(0, 100)}...`, err);
                         reject(err);
                    };
                    img.src = src;
                });
            }

            async function drawCharacter() {
                ctx.clearRect(0, 0, characterCanvas.width, characterCanvas.height);
                
                const getPartFromSelection = (selection) => {
                    if (!selection) return null;
                    return selection.category === 'hands' ? currentCharacter.hands[selection.index] : currentCharacter[selection.category];
                };

                const partsToDraw = [];
                DRAW_ORDER.forEach(category => {
                    if (category === 'hands' && currentCharacter.hands) {
                        currentCharacter.hands.forEach(handPart => partsToDraw.push(handPart));
                    } else if (currentCharacter[category] && currentCharacter[category].src) {
                        partsToDraw.push(currentCharacter[category]);
                    }
                });

                const drawingPromises = partsToDraw.map(part => (async () => {
                    try {
                        const svgText = await getAssetAsText(part.src);
                        const finalSvgText = part.color ? colorizeSvg(svgText, part.color) : svgText;
                        const dataUrl = `data:image/svg+xml;base64,${safeBtoa(finalSvgText)}`;
                        const img = await loadImage(dataUrl);
                        return { part, img };
                    } catch (e) {
                        console.error(`Error processing a part:`, e);
                        return null;
                    }
                })());

                try {
                    const loadedParts = await Promise.all(drawingPromises);

                    loadedParts.forEach(loaded => {
                        if (loaded) {
                            const { part, img } = loaded;
                            ctx.save();
                            ctx.translate(part.x, part.y);
                            ctx.rotate(part.rotation);
                            if (part.isFlippedH) ctx.scale(-1, 1);
                            ctx.drawImage(img, -part.width / 2, -part.height / 2, part.width, part.height);
                            ctx.restore();
                        }
                    });

                    const selectedPartObject = getPartFromSelection(selectedPartOnCanvas);
                    if (selectedPartObject) drawTransformHandles(selectedPartObject);
                } catch (error) {
                    console.error("An unexpected error occurred during character drawing:", error);
                }
            }

            function getPartHandles(part) {
                const ROTATE_HANDLE_OFFSET = 20;
                const halfW = part.width / 2;
                const halfH = part.height / 2;
                return {
                    topLeft:     { x: -halfW, y: -halfH, type: 'resize', cursor: 'nwse-resize' },
                    topRight:    { x: halfW,  y: -halfH, type: 'resize', cursor: 'nesw-resize' },
                    bottomRight: { x: halfW,  y: halfH,  type: 'resize', cursor: 'nwse-resize' },
                    bottomLeft:  { x: -halfW, y: halfH,  type: 'resize', cursor: 'nesw-resize' },
                    rotate:      { x: 0,      y: -halfH - ROTATE_HANDLE_OFFSET, type: 'rotate', cursor: 'crosshair' }
                };
            }

            function drawTransformHandles(part) {
                const HANDLE_SIZE = 8;

                ctx.save();
                ctx.translate(part.x, part.y);
                ctx.rotate(part.rotation);

                ctx.strokeStyle = '#4C97FF';
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 2]);
                ctx.strokeRect(-part.width / 2, -part.height / 2, part.width, part.height);
                ctx.setLineDash([]);

                const handles = getPartHandles(part);
                ctx.fillStyle = 'white';
                ctx.strokeStyle = '#4C97FF';
                ctx.lineWidth = 2;
                
                Object.values(handles).forEach(handle => {
                    if (handle.type === 'resize') {
                       ctx.strokeRect(handle.x - HANDLE_SIZE / 2, handle.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                       ctx.fillRect(handle.x - HANDLE_SIZE / 2, handle.y - HANDLE_SIZE / 2, HANDLE_SIZE, HANDLE_SIZE);
                    } else if (handle.type === 'rotate') {
                        ctx.beginPath();
                        ctx.moveTo(0, -part.height / 2);
                        ctx.lineTo(handle.x, handle.y + HANDLE_SIZE / 2);
                        ctx.stroke();

                        ctx.beginPath();
                        ctx.arc(handle.x, handle.y, HANDLE_SIZE / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }
                });
                
                ctx.restore();
            }

            function selectPart(category, partSrc, thumbElement) {
                if (category === 'hand') {
                    const getSelectedPartObject = () => (!selectedPartOnCanvas || selectedPartOnCanvas.category !== 'hands') ? null : currentCharacter.hands[selectedPartOnCanvas.index];
                    const selectedHand = getSelectedPartObject();

                    if (selectedHand) {
                        selectedHand.src = partSrc;
                    } else if (currentCharacter.hands.length < 2) {
                        const props = PART_PROPORTIONS.hand;
                        const w = characterCanvas.width * props.scale.w;
                        const h = characterCanvas.height * props.scale.h;
                        const xOffset = currentCharacter.hands.length === 0 ? props.offset.x : 1 - props.offset.x;
                        currentCharacter.hands.push({ 
                            category: 'hand', src: partSrc, 
                            x: xOffset * characterCanvas.width, y: props.offset.y * characterCanvas.height,
                            width: w, height: h, rotation: 0, color: null, isFlippedH: false 
                        });
                    }
                } else {
                    if (currentCharacter[category]) currentCharacter[category].src = partSrc;
                    if (category === 'dresses') {
                        if(currentCharacter.shirt) currentCharacter.shirt.src = '';
                        if(currentCharacter.pants) currentCharacter.pants.src = '';
                    } else if (['shirt', 'pants'].includes(category)) {
                        if (currentCharacter.dresses) currentCharacter.dresses.src = '';
                    }
                }

                thumbElement.parentElement.querySelectorAll('.part-thumbnail').forEach(t => t.classList.remove('selected'));
                thumbElement.classList.add('selected');
                drawCharacter();
            }

            function populateParts(category) {
                activeCreatorCategory = category;
                creatorPartsGrid.innerHTML = '';
                const categoryData = ASSET_CATEGORIES[category];

                if (categoryData) {
                    categoryData.parts.forEach(partSrc => {
                        const thumb = document.createElement('div');
                        thumb.className = 'part-thumbnail';
                        if (category !== 'hand' && currentCharacter[category]?.src === partSrc) {
                            thumb.classList.add('selected');
                        }
                        thumb.innerHTML = `<img src="${partSrc}">`;
                        thumb.addEventListener('click', () => selectPart(category, partSrc, thumb));
                        creatorPartsGrid.appendChild(thumb);
                    });
                }
            }

            function selectCategory(category, buttonElement) {
                creatorCategoriesContainer.querySelectorAll('.category-button').forEach(b => b.classList.remove('active'));
                buttonElement.classList.add('active');
                populateParts(category);
            }

            function initializeCreator() {
                 creatorCategoriesContainer.innerHTML = '';
                 for (const key in ASSET_CATEGORIES) {
                    const category = ASSET_CATEGORIES[key];
                    const button = document.createElement('button');
                    button.className = 'category-button';
                    button.textContent = category.label;
                    button.dataset.category = key;
                    if (key === activeCreatorCategory) button.classList.add('active');
                    button.addEventListener('click', () => selectCategory(key, button));
                    creatorCategoriesContainer.appendChild(button);
                 }
                 
                 currentCharacter = { hands: [] };
                 DRAW_ORDER.forEach(cat => {
                    if (cat !== 'hands' && ASSET_CATEGORIES[cat]) {
                        const isDefaultPart = cat !== 'dresses';
                        const firstPartSrc = isDefaultPart ? ASSET_CATEGORIES[cat]?.parts[0] : '';
                        const props = PART_PROPORTIONS[cat];
                        currentCharacter[cat] = { 
                            category: cat, src: firstPartSrc, 
                            x: props.offset.x * characterCanvas.width, y: props.offset.y * characterCanvas.height,
                            width: characterCanvas.width * props.scale.w, height: characterCanvas.height * props.scale.h, 
                            rotation: 0, color: null 
                        };
                    }
                 });
                 
                selectedPartOnCanvas = null;
                creatorControlsPanel.classList.add('hidden');
                populateParts(activeCreatorCategory);
                drawCharacter();
            }
            
            function openCreatorForEdit(spriteId) {
                const spriteData = sprites[spriteId];
                if (!spriteData || !spriteData.isCustom || !spriteData.characterData) return;
                editingSpriteId = spriteId;
                currentCharacter = JSON.parse(JSON.stringify(spriteData.characterData));
                if (!currentCharacter.hands) currentCharacter.hands = [];
                activeCreatorCategory = Object.keys(ASSET_CATEGORIES)[0];
                
                creatorCategoriesContainer.innerHTML = '';
                 for (const key in ASSET_CATEGORIES) {
                    const category = ASSET_CATEGORIES[key];
                    const button = document.createElement('button');
                    button.className = 'category-button';
                    button.textContent = category.label;
                    button.dataset.category = key;
                    if (key === activeCreatorCategory) button.classList.add('active');
                    button.addEventListener('click', () => selectCategory(key, button));
                    creatorCategoriesContainer.appendChild(button);
                 }
                
                populateParts(activeCreatorCategory);
                selectedPartOnCanvas = null;
                creatorControlsPanel.classList.add('hidden');
                drawCharacter();
                creatorModal.classList.add('visible');
            }


            function populateColorPalette() {
                creatorColorPalette.innerHTML = '';
                const category = selectedPartOnCanvas?.category === 'hands' ? 'hand' : selectedPartOnCanvas?.category;
                const colorsToShow = (category === 'hand' || category === 'head') ? SKIN_TONE_PALETTE : COLOR_PALETTE;

                colorsToShow.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color;
                    swatch.dataset.color = color;
                    creatorColorPalette.appendChild(swatch);
                });
            }

            createSpriteHeaderButton.addEventListener('click', () => {
                editingSpriteId = null;
                initializeCreator();
                creatorModal.classList.add('visible');
            });
            creatorCloseButton.addEventListener('click', () => {
                creatorModal.classList.remove('visible');
                editingSpriteId = null;
            });

            creatorSaveButton.addEventListener('click', () => {
                const previouslySelected = selectedPartOnCanvas;
                selectedPartOnCanvas = null;
                drawCharacter().then(() => {
                    try {
                        const dataUrl = characterCanvas.toDataURL('image/png');
                        const characterDataToSave = JSON.parse(JSON.stringify(currentCharacter));

                        if (editingSpriteId) {
                            const spriteToEdit = sprites[editingSpriteId];
                            spriteToEdit.imageUrl = dataUrl;
                            spriteToEdit.characterData = characterDataToSave;
                            document.querySelector(`#container-${editingSpriteId} img`).src = dataUrl;
                            document.querySelector(`.sprite-card[data-sprite-id="${editingSpriteId}"] img`).src = dataUrl;
                        } else {
                            createNewSprite('דמות חדשה', dataUrl, 0, 0, true, characterDataToSave);
                        }
                        creatorModal.classList.remove('visible');
                        editingSpriteId = null;
                    } catch (e) {
                         console.error("שגיאה בשמירת הדמות:", e);
                    } finally {
                        selectedPartOnCanvas = previouslySelected;
                    }
                });
            });

            // --- Vector Manipulation Logic ---
            function getCanvasCoordinates(e) {
                const rect = characterCanvas.getBoundingClientRect();
                const pointer = e.touches ? e.touches[0] : e;
                return { x: pointer.clientX - rect.left, y: pointer.clientY - rect.top };
            }

            function getPartAt(point) {
                 const reversedParts = [];
                 DRAW_ORDER.slice().reverse().forEach(category => {
                    if (category === 'hands' && currentCharacter.hands) {
                        currentCharacter.hands.slice().reverse().forEach((handPart, index) => reversedParts.push({ part: handPart, selection: { category: 'hands', index: 1-index } }));
                    } else if (currentCharacter[category] && currentCharacter[category].src) {
                        reversedParts.push({ part: currentCharacter[category], selection: { category } });
                    }
                });

                for (const { part, selection } of reversedParts) {
                    ctx.save();
                    ctx.translate(part.x, part.y);
                    ctx.rotate(part.rotation);
                    ctx.beginPath();
                    ctx.rect(-part.width / 2, -part.height / 2, part.width, part.height);
                    ctx.restore();
                    if (ctx.isPointInPath(point.x, point.y)) return selection;
                }
                return null;
            }

            function getHandleAt(part, point) {
                const handles = getPartHandles(part);
                const HANDLE_INTERACTION_SIZE = 12;

                for (const handleName in handles) {
                    const handle = handles[handleName];
                    const transformedHandle = {
                        x: part.x + handle.x * Math.cos(part.rotation) - handle.y * Math.sin(part.rotation),
                        y: part.y + handle.x * Math.sin(part.rotation) + handle.y * Math.cos(part.rotation),
                    };
                    if (Math.hypot(point.x - transformedHandle.x, point.y - transformedHandle.y) < HANDLE_INTERACTION_SIZE) {
                        return handleName;
                    }
                }
                return null;
            }
            
            function updateCursor(e) {
                const point = getCanvasCoordinates(e);
                let newCursor = 'default';
                const partSelection = getPartAt(point);
                const partObj = partSelection ? (partSelection.category === 'hands' ? currentCharacter.hands[partSelection.index] : currentCharacter[partSelection.category]) : null;

                if (partObj) {
                    const handle = getHandleAt(partObj, point);
                    if (handle) {
                        newCursor = getPartHandles(partObj)[handle].cursor;
                    } else {
                        newCursor = 'move';
                    }
                }
                characterCanvas.style.cursor = newCursor;
            }


            characterCanvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const point = getCanvasCoordinates(e);
                const partSelection = getPartAt(point);
                
                if (partSelection) {
                    const part = partSelection.category === 'hands' ? currentCharacter.hands[partSelection.index] : currentCharacter[partSelection.category];
                    const handle = getHandleAt(part, point);
                    
                    creatorAction.partSelection = partSelection;
                    creatorAction.startX = point.x;
                    creatorAction.startY = point.y;
                    creatorAction.initialState = JSON.parse(JSON.stringify(part));

                    if (handle) {
                        creatorAction.type = 'transform';
                        creatorAction.handle = handle;
                    } else {
                        creatorAction.type = 'move';
                    }
                } else {
                    creatorAction.type = 'none';
                }
                
                selectedPartOnCanvas = partSelection;
                if (selectedPartOnCanvas) {
                    creatorControlsPanel.classList.remove('hidden');
                    const labelText = ASSET_CATEGORIES[selectedPartOnCanvas.category === 'hands' ? 'hand' : selectedPartOnCanvas.category].label;
                    selectedPartLabel.textContent = labelText;
                    populateColorPalette();
                    creatorFlipHButton.classList.toggle('hidden', selectedPartOnCanvas.category !== 'hand');
                } else {
                    creatorControlsPanel.classList.add('hidden');
                }
                drawCharacter();
            });

            characterCanvas.addEventListener('mousemove', (e) => {
                if (creatorAction.type === 'none') {
                    updateCursor(e);
                    return;
                }
                e.preventDefault();

                const point = getCanvasCoordinates(e);
                const part = creatorAction.partSelection.category === 'hands' ? currentCharacter.hands[creatorAction.partSelection.index] : currentCharacter[creatorAction.partSelection];
                
                if (creatorAction.type === 'move') {
                    part.x = creatorAction.initialState.x + (point.x - creatorAction.startX);
                    part.y = creatorAction.initialState.y + (point.y - creatorAction.startY);
                } else if (creatorAction.type === 'transform') {
                    const handle = creatorAction.handle;
                    
                    if (handle === 'rotate') {
                        const centerX = creatorAction.initialState.x;
                        const centerY = creatorAction.initialState.y;
                        const initialAngle = Math.atan2(creatorAction.startY - centerY, creatorAction.startX - centerX);
                        const currentAngle = Math.atan2(point.y - centerY, point.x - centerX);
                        part.rotation = creatorAction.initialState.rotation + (currentAngle - initialAngle);
                    } else { // Resize
                        // Transform mouse delta into part's local coordinate system
                        const dx = point.x - creatorAction.startX;
                        const dy = point.y - creatorAction.startY;
                        const cos = Math.cos(-part.rotation);
                        const sin = Math.sin(-part.rotation);
                        const localDx = dx * cos - dy * sin;
                        const localDy = dx * sin + dy * cos;

                        let dw = 0, dh = 0, cx = 0, cy = 0;
                        if (handle.includes('Right')) { dw = localDx; cx = localDx/2; }
                        if (handle.includes('Left')) { dw = -localDx; cx = localDx/2; }
                        if (handle.includes('Bottom')) { dh = localDy; cy = localDy/2; }
                        if (handle.includes('Top')) { dh = -localDy; cy = localDy/2; }
                        
                        part.width = creatorAction.initialState.width + dw;
                        part.height = creatorAction.initialState.height + dh;
                        
                        part.x = creatorAction.initialState.x + (cx * cos - cy * sin);
                        part.y = creatorAction.initialState.y + (cx * sin + cy * cos);
                    }
                }
                drawCharacter();
            });

            document.addEventListener('mouseup', () => {
                creatorAction.type = 'none';
            });
            
            creatorColorPalette.addEventListener('click', (e) => {
                if (e.target.classList.contains('color-swatch') && selectedPartOnCanvas) {
                    const part = selectedPartOnCanvas.category === 'hands' ? currentCharacter.hands[selectedPartOnCanvas.index] : currentCharacter[selectedPartOnCanvas.category];
                    part.color = e.target.dataset.color;
                    drawCharacter();
                }
            });
            
            creatorFlipHButton.addEventListener('click', () => {
                if (selectedPartOnCanvas && selectedPartOnCanvas.category === 'hands') {
                    const hand = currentCharacter.hands[selectedPartOnCanvas.index];
                    hand.isFlippedH = !hand.isFlippedH;
                    drawCharacter();
                }
            });


            // --- Main Animation Loop ---
            let lastTime = 0;
            function mainLoop(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;

                if (scriptRunner) scriptRunner.tick();
                updateGifAnimations(deltaTime);

                requestAnimationFrame(mainLoop);
            }
            
            // --- Initialization ---
            function init() {
                const uploadSpriteHeaderButton = document.getElementById('upload-sprite-header-button');
                const spriteUploadInput = document.getElementById('sprite-upload-input');
                const uploadBackdropHeaderButton = document.getElementById('upload-backdrop-header-button');
                const backdropUploadInput = document.getElementById('backdrop-upload-input');

                addSpriteButton.addEventListener('click', () => spriteGallery.classList.add('visible'));
                closeSpriteGalleryButton.addEventListener('click', () => spriteGallery.classList.remove('visible'));
                spriteThumbnailsGrid.addEventListener('click', handleSpriteGallerySelection);
                uploadSpriteHeaderButton.addEventListener('click', () => spriteUploadInput.click());
                spriteUploadInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => createNewSprite(file.name.split('.')[0], event.target.result);
                        reader.readAsDataURL(file);
                    }
                    e.target.value = null;
                });

                addBackdropButton.addEventListener('click', () => backgroundGallery.classList.add('visible'));
                closeGalleryButton.addEventListener('click', () => backgroundGallery.classList.remove('visible'));
                thumbnailsGrid.addEventListener('click', handleGallerySelection);
                uploadBackdropHeaderButton.addEventListener('click', () => backdropUploadInput.click());
                backdropUploadInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if(file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                           const newCard = createBackdropCard(event.target.result);
                           window.switchBackdrop(event.target.result);
                        };
                        reader.readAsDataURL(file);
                    }
                    e.target.value = null;
                });
                
                backdropsList.addEventListener('click', handleBackdropSelection);

                createDefaultBackdrop();
                createDefaultSprite();
                setupPropertiesPanelListeners();

                requestAnimationFrame(mainLoop);
            }

            init();
        });
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>